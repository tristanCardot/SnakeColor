<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>SnakeColor</title>
	<style id='style'>
		div#craftGeo{
			background-position: -0px -0px;
			position:absolute;
			top:0px;
			left:120px;
			height:60px;
			width:60px;
			box-shadow: inset 0px 0px 1px 1px black, 0px 0px 5px black;
			transition:all 500ms;
		}

		div#craftGeo:hover span{
			left:0px;
		}

		body{
			height:0px;
			width:0px;

			margin:0px;
		}

		body div{
			position:absolute;

		}

		canvas{
			position: absolute;
			top:0px;
			left:0px;
			height:100%;
			width:100%;
		}

		div#craftBox{
			height:60px;
			width:180px;
			box-shadow:0px 0px 5px 2px black;
		}


		div#craftGeo:hover{
			width:300px;
			background-position:0px 0px;
		}	

		div#craftGeo span{
			position: relative;
			left:0px;
			height:60px;
			width:60px;
			box-shadow: inset 0px 0px 6px 2px white, 0px 0px 2px 1px white;
			display: inline-block;
			transition:all 500ms;
		}

		div#craftColor{
			height:60px;
			width:120px;
		}

		div#craftColor span{
			border:solid 1px black;
			height:28px;
			width:28px;
			box-shadow: inset 0px 0px 6px 2px black;
			margin: 0px -4px -5px 0px;
			display: inline-block;
		}

		div#craftColor span:hover{
			box-shadow: inset 0px 0px 6px 2px black, inset 0px 0px 4px 4px rgb(125,125,125);
		}
		div#craftColor span.select{
			box-shadow: inset 0px 0px 6px 2px black, inset 0px 0px 6px 6px rgb(200,200,200);
		}

		span.BLACK{ background-color:black;}
		span.GREEN{ background-color:green;}
		span.RED{ background-color:red;}
		span.YELLOW{ background-color:yellow;}
		span.BLUE{ background-color:blue;}
		span.CYAN{ background-color:cyan;}
		span.VIOLET{ background-color:magenta;}
		span.WHITE{ background-color:white;}

		div#levelList{
			top:25px;
			width:270px;
		}

		div#levelList span.active{
			background-color:rgba(255,255,255,.5);
		}

		div#levelList span{
			display: inline-block;
			text-align: center;
			padding-top:10px;
			height:20px;
			width:30px;
			border:solid 1px black;
			margin:3px;
		}

	</style>
	<script type="text/javascript" charset="UTF-8" src="three.min.js"></script>
	<script>

//- STATIC
		var SCREENY = 0,
			FOV = 75,
			V3 = THREE.Vector3,
			F3 = THREE.Face3,
			CANVAS,

			LEVELS = [
				"FFAAGAAAMAMAABAAMBBBMAABAAMAMAA",
				"FFCCDANAAAMAFAEAAAAABAGAAAOABAB",
				"HLBDFABAAAAABBBAAABBABAAABAABADABABADMDAABAADAABABAAABAABAAABABAALAABBALELABBBALABB",
				"LLAETAAAABAANAAAAAPABAAAOAAAAAAOAAPAANAMAMAAABAABBAAABAEANAAAANAAGAFAAPAAAAAAHABAAABBOABAPAOAAAAAAAAAAAANAOAAMAABMAAAAAPAAABAAA",
				"FPHEKAAAAAAAAAAAAABNNABAMHABAAAAODMAABAAAGBEBAABAAAAODMAABAAAABAMFAABPPAAAAAAAAAA"
			],

			GUI = {
				MAIN : 0,
				GUIPLAYER : 1,
				INGAME : 2,
				LEVELSELECT : 3,
				CRAFTBOX : 4,
				CRAFTMENU : 5
			},

			COLOR = {
				BLACK: 0,
				GREEN: 1,
				RED: 2,
				YELLOW: 3,
				BLUE: 4,
				CYAN: 5,
				VIOLET: 6,
				WHITE: 7,

				RGB:[
					new V3(0,0,0),
					new V3(1/255*40, 1/255*180, 1/255*20),
					new V3(1,0,0),
					new V3(1,1,0),
					new V3(0,0,1),
					new V3(0,1,1),
					new V3(1,0,1),
					new V3(1,1,1)
				]
			};

		var GEO = {
			snakePart: (function(){
				var geo = new THREE.Geometry();
				geo.vertices = convertArray([
					-.4, .4, -.4,
					-.4, .4,  .4, 
					 .4, .4,  .4,
					 .4, .4, -.4,

					-.4, .4, -.4,
					-.4, .0, -.4,
					-.4, .0,  .4,
					-.4, .4,  .4, 

					-.4, .4,  .4, 
					-.4, .0,  .4,
					 .4, .0,  .4,
					 .4, .4,  .4,

					 .4, .4,  .4,
					 .4, .0,  .4,
					 .4, .0, -.4,
					 .4, .4, -.4,

					 .4, .4, -.4,
					 .4, .0, -.4,
					-.4, .0, -.4,
					-.4, .4, -.4
				], THREE.Vector3);

				geo.faces = convertArray([
					0,1,2,    0,2,3,
					4,5,6,    4,6,7,
					8,9,10,   8,10,11,
					12,13,14, 12,14,15,
					16,17,18, 16,18,19
				], THREE.Face3);
				return geo;
			})(),

			dot: (function(){
				var geo = new THREE.Geometry();
				geo.vertices = convertArray([
					-.1, .1, -.1,
					-.1, .1,  .1, 
					 .1, .1,  .1,
					 .1, .1, -.1,

					-.1, .0, -.1,
					-.1, .0,  .1,
					 .1, .0,  .1,
					 .1, .0, -.1
				], THREE.Vector3);

				geo.faces = convertArray([
					0,1,2, 0,2,3,
					0,4,5, 0,5,1,
					1,5,6, 1,6,2,
					2,6,7, 2,7,3,
					3,7,4, 3,4,0,
					5,4,7, 5,7,6 
				], THREE.Face3);
				return geo;
			})(),

			colorSwaper: (function(){
				var geo = new THREE.Geometry();
				geo.vertices = convertArray([
					-.0, 0, -.0,
					-.0, 0,  .0, 
					 .0, 0,  .0,
					 .0, 0, -.0,

					-.2,  .1, -.2,
					-.2,  .1,  .2,
					 .2,  .1,  .2,
					 .2,  .1, -.2,

					-.4, 0, -.4,
					-.4, 0,  .4,
					 .4, 0,  .4,
					 .4, 0, -.4
				], THREE.Vector3);

				geo.faces = convertArray([
					0,4,5, 0,5,1,
					1,5,6, 1,6,2,
					2,6,7, 2,7,3,
					3,7,4, 3,4,0,

					0,5,4, 0,1,5,
					1,6,5, 1,2,6,
					2,7,6, 2,3,7,
					3,4,7, 3,0,4,

					4,8,9,   4,9,5,
					5,9,10,  5,10,6,
					6,10,11, 6,11,7,
					7,11,8,  7,8,4

				], THREE.Face3);

				return geo;
			})(),

			ground: (function(){
				var geo = new THREE.Geometry();
				geo.vertices = convertArray([
					-.4,  0, -.4,
					-.4,  0,  .4,
					 .4,  0,  .4,
					 .4,  0, -.4,

					-.4,   0, -.4,
					-.5, -.1, -.5,
					-.5, -.1,  .5,
					-.4,   0,  .4,

					-.4,   0,  .4,
					-.5, -.1,  .5,
					 .5, -.1,  .5,
					 .4,   0,  .4,

					 .4,   0,  .4,
					 .5, -.1,  .5,
					 .5, -.1, -.5,
					 .4,   0, -.4,

					 .4,   0, -.4,
					 .5, -.1, -.5,
					-.5, -.1, -.5,
					-.4,   0, -.4
				], THREE.Vector3);

				geo.faces = convertArray([
					0,1,2,    0,2,3,
					4,5,6,    4,6,7,
					8,9,10,   8,10,11,
					12,13,14, 12,14,15,
					16,17,18, 16,18,19
				], THREE.Face3);

				return geo;
			})(),

			

			wall: (function(){
				var geo = new THREE.Geometry();
				geo.vertices = convertArray([
					-.4,.4,-.4,  -.4,.4,.4,  .4,.4,.4,  .4,.4,-.4,

					-.4,.4,-.4,  -.5,.3,-.4,  -.5,.3,.4,  -.4,.4,.4,
					-.4,.4,.4,  -.4,.3,.5,  .4,.3,.5,  .4,.4,.4,
					.4,.4,.4,  .5,.3,.4,  .5,.3,-.4,  .4,.4,-.4,
					.4,.4,-.4,  .4,.3,-.5,  -.4,.3,-.5,  -.4,.4,-.4,

					-.4,.4,-.4, -.4,.3,-.5, -.5,.3,-.4,
					-.4,.4,.4, -.5,.3,.4, -.4,.3,.5,
					.4,.4,.4,  .4,.3,.5,  .5,.3,.4,
					.4,.4,-.4, .5,.3,-.4, .4,.3,-.5,

					-.5,.3,-.4,  -.5,-.1,-.4,  -.5,-.1,.4,  -.5,.3,.4,
					-.4,.3,.5,  -.4,-.1,.5,  .4,-.1,.5,  .4,.3,.5,
					.5,.3,.4,  .5,-.1,.4,  .5,-.1,-.4,  .5,.3,-.4,
					.4,.3,-.5,  .4,-.1,-.5,  -.4,-.1,-.5,  -.4,.3,-.5,

					-.4,.3,-.5, -.4,-.1,-.5, -.5,-.1,-.4, -.5,.3,-.4,
					 -.5,.3,.4, -.5,-.1,.4, -.4,-.1,.5, -.4,.3,.5,
					.4,.3,.5, .4,-.1,.5, .5,-.1,.4, .5,.3,.4,
					.5,.3,-.4, .5,-.1,-.4, .4,-.1,-.5, .4,.3,-.5,

					-.5,-.1,-.5, -.5,-.1,-.4, -.4,-.1,-.5,
					-.5,-.1,.5, -.4,-.1,.5, -.5,-.1,.4,
					.5,-.1,.5, .5,-.1,.4, .4,-.1,.5,
					.5,-.1,-.5, .4,-.1,-.5, .5,-.1,-.4
				], THREE.Vector3);

				geo.faces = convertArray([
					0,1,2,    0,2,3,
					4,5,6,    4,6,7,
					8,9,10,   8,10,11,
					12,13,14, 12,14,15,
					16,17,18, 16,18,19,

					20,21,22, 23,24,25,
					26,27,28, 29,30,31,

					32,33,34, 32,34,35,
					36,37,38, 36,38,39,
					40,41,42, 40,42,43,
					44,45,46, 44,46,47,

					48,49,50, 48,50,51,
					52,53,54, 52,54,55,
					56,57,58, 56,58,59,
					60,61,62, 60,62,63,

					64,65,66, 67,68,69,
					70,71,72, 73,74,75

				], THREE.Face3);

				return geo;
			})()
		};

		var MAT = {
			snakeColor : (function(){
				var vert = [
					"#ifdef GL_ES",
					"precision mediump float;",
					"#endif",

					"attribute float saturation;",
					"varying float vSaturation;",

					"void main(){",
						"vSaturation = saturation;",
						"gl_Position = projectionMatrix *modelViewMatrix *vec4(position, 1.0);",
					"}"
				].join('\n');
				var frag = [
					"#ifdef GL_ES",
					"precision mediump float;",
					"#endif",

					"uniform vec3 color;",
					"varying float vSaturation;",

					"void main(void){",
						"gl_FragColor = vec4(color *vSaturation, 1.);",
					"}"
				].join('\n');

				return new THREE.ShaderMaterial({
					uniforms: {color : {type: 'v3', value: new V3(0,0,0)} },
					attributes: {saturation : {type: 'f', value: [
						.75, .75, .75, .75,
						  1,   1,   1,   1,
						 .9,  .9,  .9,  .9,
						 .6,  .6,  .6,  .6,
						.45, .45, .45, .45
					]} },
					vertexShader:   vert,
					fragmentShader: frag
				});
			})(),

			color : (function(){
				var vert = [
					"#ifdef GL_ES",
					"precision mediump float;",
					"#endif",

					"void main(){",
						"gl_Position = projectionMatrix *modelViewMatrix *vec4(position, 1.0);",
					"}"
				].join('\n');
				var frag = [
					"#ifdef GL_ES",
					"precision mediump float;",
					"#endif",

					"uniform vec3 color;",

					"void main(void){",
						"gl_FragColor = vec4(color, 1.);",
					"}"
				].join('\n');
				var attributes = [];

				return new THREE.ShaderMaterial({
			        uniforms: {color : {type: 'v3', value: new V3(0,0,0)} },
			        attributs : {},
			        vertexShader:   vert,
			        fragmentShader: frag
			    });
			})(),

			alphaGradient : (function(){
				var vert = [
					"#ifdef GL_ES",
					"precision mediump float;",
					"#endif",

		    		"varying float vAlpha;",
		    		"attribute float alpha;",

					"void main(){",
						"vAlpha = alpha;",
						"gl_Position = projectionMatrix *modelViewMatrix *vec4(position, 1.0);",
					"}"
				].join('\n');
				var frag = [
					"#ifdef GL_ES",
					"precision mediump float;",
					"#endif",

					"uniform vec3 color;",
		    		"varying float vAlpha;",

					"void main(void){",
						"gl_FragColor = vec4(color, vAlpha);",
					"}"
				].join('\n');
				var attributes = [];

				return new THREE.ShaderMaterial({
			        uniforms: {color : {type: 'v3', value: new V3(0,0,0)} },
			        attributes: {alpha : {type: 'f', value: [-.5,-.5,-.5,-.5, .75,.75,.75,.75, 0,0,0,0]} },
			        vertexShader:   vert,
			        fragmentShader: frag,
			        transparent: true
			    });
			})(),

			grayGradient : (function(){
				var vert = [
					"#ifdef GL_ES",
					"precision mediump float;",
					"#endif",

		    		"varying float vGrad;",
		    		"attribute float grad;",

					"void main(){",
						"vGrad = grad;",
						"gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0 );",
					"}"
				].join('\n');
				var frag = [
					"#ifdef GL_ES",
					"precision mediump float;",
					"#endif",

		    		"varying float vGrad;",

					"void main(void){",
						"gl_FragColor = vec4(vGrad, vGrad, vGrad,1.);",
					"}"
				].join('\n');
				var attributes = [];

				return new THREE.ShaderMaterial({
			        uniforms: {},
			        attributes: {
			        	grad : {type: 'f', value: []}
			        },
			        vertexShader:   vert,
			        fragmentShader: frag
			    });
			})()
		};

		function convertArray(list, type, length){
			var r = [];//result

				for(var i=0; i<list.length; i+=3)
					r.push(new type(list[i], list[i+1], list[i+2]));

			return r;
		}


//- SNAKE
		function Snake(){
			this.pos = {x: 0, y: 0};
			this.maxLength = 5;
			this.speed = 400;
			this.nextMove = 0;
			this.paused = true;

			this.dir = -1;
			this.parts = [];
			this.color = COLOR.GREEN;
			this.mat = TYPE.LIST[ TYPE.SNAKE].mesh.material;
		}

		Snake.prototype = {
			growUp : function(){
				this.maxLength++;
			},

			setDir : function(newDir){
				var lastPart = this.parts[this.parts.length-2];
				if(lastPart === undefined){
					this.dir = newDir;
					return;
				}

				switch(newDir){
					case 0:
							if(this.pos.x !== lastPart.x || this.pos.y !== lastPart.y+1)
								this.dir = newDir;
						break;
					case 1:
							if(this.pos.y !== lastPart.y || this.pos.x !== lastPart.x+1)
								this.dir = newDir;
						break;
					case 2:
							if(this.pos.x !== lastPart.x || this.pos.y !== lastPart.y-1)
								this.dir = newDir;
						break;
					case 3:
							if(this.pos.y !== lastPart.y || this.pos.x !== lastPart.x-1)
								this.dir = newDir;
						break;
				}
			},

			update : function(delta){
				if(this.paused)
					return;

				this.nextMove-=delta;
				if(this.nextMove>0)
					return;

				this.nextMove+=this.speed;

				switch(this.dir){
					case 0: this.pos.y--;
						break;
					case 1: this.pos.x--;
						break;
					case 2: this.pos.y++;
						break;
					case 3: this.pos.x++;
						break;
					default: return;
				}

				if(this.parts.length > this.maxLength){
					var part = this.parts[0];
					var mesh = renderManager.grid[part.x][part.y];

					map.clearPos(part.x, part.y);
					this.parts = this.parts.splice(1);

					animationManager.pushAnimation(mesh, [
						['position', {from: new V3(part.x, 0, part.y), to: new V3(this.parts[0].x, 0, this.parts[0].y)}],
						['scale', {from: new V3(1,1,1), to: new V3(.1,.1,.1)}]
					], this.speed, 0,
					function(mesh){renderManager.clearMesh(mesh);});
				}
				if(map.moveIn(this)){

					var lastPart = this.parts[this.parts.length-1];

					var mesh = renderManager.craftMesh(TYPE.LIST[TYPE.SNAKE], this.pos.x, this.pos.y);
					var vx = (this.dir === 1 ? 1 : this.dir === 3 ? -1 : 0);
					var vz = (this.dir === 0 ? 1 : this.dir === 2 ? -1 : 0);

					animationManager.pushAnimation(mesh, [
						['position', {from: new V3(this.pos.x +vx *.6, 0, this.pos.y +vz *.6), to: mesh.position.clone()}],
						['scale', {from: new V3(.1,.1,.1), to: new V3(1,1,1)}]
					], this.speed, 0);

					var camP = renderManager.cam.position.clone();

					animationManager.pushAnimation(renderManager.cam, [
						['position', {from: camP, to: new V3(this.pos.x, camP.y, this.pos.y+.75)}]
					], this.speed, 0);

					this.parts.push({x: this.pos.x, y: this.pos.y});
					map.setPos(this.pos.x, this.pos.y, TYPE.LIST[TYPE.SNAKE]);
				}else
					map.reset();
			},

			setColor : function(color){
					snake.color = color;
					snake.mat.uniforms.color.value = COLOR.RGB[ color];
			},

			reset : function(){
				this.maxLength = 5;
				this.parts = [map.spawn];
				this.dir = -1;

				snake.setColor(COLOR.GREEN);
				this.pos.x = map.spawn.x;
				this.pos.y = map.spawn.y;

				var mesh = renderManager.craftMesh(TYPE.LIST[TYPE.SNAKE], map.spawn.x, map.spawn.y);

				animationManager.pushAnimation(mesh, [
					['scale', {from: new V3(.05,.05,.05), to: new V3(1,1,1)}]
				],400, 0);

				map.grid[map.spawn.x][map.spawn.y] = TYPE.LIST[TYPE.SNAKE];
				snake.paused = false;
			}
		};


//- MAP
		function Map(){
			this.currentData = null;
			this.grid = [];
			this.ld = {};

			this.height = 0;
			this.width = 0;
			this.dotCount = 0;
			this.spawn = {x: 0, y: 0};
		}

		Map.prototype = {
			updateData : function(ld){//ld=> LevelData TODO basic
				var result = stringToArray(ld);
				this.ld = result;

				this.height = result[0];
				this.width = result[1];
				this.spawn = {x: result[2]+1, y: result[3]+1};
				this.dotCount = result[4]+ (result[5]<<5);
				//TODO clearAll RM
				renderManager.initGrid(this.height+2, this.width+2);

				this.grid = [];
				for(var i=-1, endI=this.width+1, endJ=this.height+1, length, select;  i<endI;  i++){
					this.grid.push([]);

					length = this.grid.length-1;

					for(var j=-1; j<endJ; j++){
						if(i<0 || j<0 || i>=this.width || j>=this.height)
							select = TYPE.LIST[ TYPE.WALL ];
						else
							select = TYPE.LIST[ result[i *map.height +j +6] ];


						if(select !== undefined){
							if(select.ground === true)
								renderManager.addGround(select, i+1, j+1);

							else{
								renderManager.craftMesh(select, i+1, j+1);
								renderManager.addGround(TYPE.LIST[TYPE.GROUND], i+1, j+1);
							}

							this.grid[i+1].push(select);

						}else{
							this.grid[i+1].push(TYPE.LIST[TYPE.GROUND]);
							renderManager.addGround(TYPE.LIST[TYPE.GROUND], i+1, j+1);
						}
					}
				}

				snake.reset();
			},

			moveIn : function(snake){
				return this.grid[snake.pos.x][snake.pos.y].moveIn(snake, renderManager.grid[snake.pos.x][snake.pos.y]);
			},

			clearPos : function(x, y){
				this.grid[x][y] = TYPE.LIST[TYPE.GROUND];
			},

			setPos : function(x, y, type){
				this.grid[x][y] = type;
			},

			updateDotCount : function(offset){
				this.dotCount += offset;

				if(this.dotCount <= 0){
					actionManager.startNextLevel();
					return false;
				}

				return true;
			},

			reset : function(){
				snake.paused = true;
				snake.dir = -1;

				this.dotCount = this.ld[4];

				for(var i= (snake.parts.length>25 ? snake.parts.length-25 : 0); i<snake.parts.length; i++){
					var mesh = renderManager.grid[snake.parts[i].x][snake.parts[i].y];

					animationManager.pushAnimation(mesh, [
						['rotation', {from: new V3(0,0,0), to: new V3(0, Math.PI*1.5, 0)}],
						['scale', {from: new V3(1,1,1), to: new V3(0.05, 0.05, 0.05)}]
					], 400, i*50,
					function(mesh){renderManager.clearMesh(mesh);});
				}

				animationManager.pushAnimation(renderManager.cam, [
						['position', {from: renderManager.cam.position.clone(), to: new V3(map.spawn.x, renderManager.cam.position.y, map.spawn.y+.5)}]
					], 250, Math.min(25, snake.parts.length) *50+200,
					function(){
						renderManager.clearGrid();

						for(var i=0, j; i<map.width; i++)
							for(var j=0; j<map.height; j++){
								select = TYPE.LIST[ map.ld[i *map.height +j +6] ];

								if(select !== undefined)
									if(select.ground !== true){
										renderManager.craftMesh(select, i+1, j+1);
										map.grid[i+1][j+1] = select;

									}else{
										renderManager.clearPos(i+1, j+1);
										map.grid[i+1][j+1] = select;
									}
							}

						snake.reset();
					});
			}
		};


//- ANIMATION
		function AnimationManager(){
			this.list = [];
		}

		AnimationManager.prototype = {
			pushAnimation : function(mesh, param, duration, delay, callback){
				if(mesh != null)
					this.list.push(new Animation(mesh, param, duration, delay, callback));
			},

			update : function(delta){
				for(var i=0; i<this.list.length; i++)
					if(this.list[i].update(delta)){
						this.list.splice(i,1);
						i--;
					}
			}
		};

		function Animation(mesh, param, duration, delay, callback){
			this.mesh = mesh;
			this.param = param;
			this.duration = duration;
			this.delay = delay || 0;
			this.callback = callback;

			if(this.delay === 0)
				for(var i=0; i<this.param.length; i++)
					this.mesh[this.param[i][0]].set(
						this.param[i][1].from.x,
						this.param[i][1].from.y,
						this.param[i][1].from.z
					);
		}

		Animation.prototype = {
			update : function(delta){
				this.delay -= delta;

				if(this.delay>0)
					return;

				var off = -this.delay/ this.duration;

				if(off>1)
					off = 1;

				var offN = 1-off;

				for(var i=0; i<this.param.length; i++)
					this.mesh[this.param[i][0]].set(
						this.param[i][1].from.x *offN + this.param[i][1].to.x *off,
						this.param[i][1].from.y *offN + this.param[i][1].to.y *off,
						this.param[i][1].from.z *offN + this.param[i][1].to.z *off
					);

				if(off === 1){
					if(this.callback)
						this.callback(this.mesh);
					return true;
				}

				return false;
			}
		};


//- ENTITIES CONSTRUCTOR + STATIC
		function SnakePart(){
			this.color;
			this.mesh = this.craftMesh();
		}

		SnakePart.prototype = {
			moveIn : function(){
				return false;
			},

			craftMesh : function(){
				var mat = MAT.snakeColor.clone();
				this.color = mat.uniforms.color.value = COLOR.RGB[ COLOR.GREEN ];

				return new THREE.Mesh(GEO.snakePart, mat);
			}
		};


		function ColorSwaper(color, pos){
			this.color = color;
			this.mesh = this.craftMesh();
		}

		ColorSwaper.prototype =	{
			moveIn : function(snake, mesh){
				snake.setColor(this.color);

				animationManager.pushAnimation(mesh, [
						['scale', {from: new V3(1,1,1), to: new V3(.05,.05,.05)}]
					], 500, 0, function(mesh){
						renderManager.clearMesh(mesh);
					});

				return true;
			},

			craftMesh : function(){
				var mat = MAT.alphaGradient.clone();
				mat.uniforms.color.value = COLOR.RGB[this.color];

				return new THREE.Mesh(GEO.colorSwaper, mat);
			}
		};

		function Block(height){
			this.height = height;
			this.mesh = this.craftMesh();
			this.ground = true;
		}

		Block.prototype = {
			moveIn : function(snake){
				return this.height === 0;
			},

			craftMesh : function(){
				var mat = MAT.grayGradient.clone(),
					geo;

				if(this.height === 0){
					geo = GEO.ground;
					mat.attributes = {grad: {type:'f', value:[.35,.35,.35,.35, .45,.45,.45,.45, .40,.40,.40,.40, .3,.3,.3,.3, .25,.25,.25,.25]}};

				}else{
					geo = GEO.wall;
					mat.attributes = {grad: {type:'f', value:[
						.25,.25,.25,.25,

						.35,.35,.35,.35,
						.30,.30,.30,.30,
						.2,.2,.2,.2,
						.15,.15,.15,.15,

						.25,.25,.25,
						.325,.325,.325,
						.25,.25,.25,
						.175,.175,.175,

						.4,.4,.4,.4,
						.35,.35,.35,.35,
						.25,.25,.25,.25,
						.2,.2,.2,.2,

						.3,.3,.3,.3,
						.375,.375,.375,.375,
						.3,.3,.3,.3,
						.225,.225,.225,.225,

						.35,.35,.35,
						.35,.35,.35,
						.35,.35,.35,
						.35,.35,.35
					]}};
				}

				return new THREE.Mesh(geo, mat);
			}
		};

		function Dot(color){
			this.color = color;
			this.mesh = this.craftMesh();
		}

		Dot.prototype = {
			moveIn : function(snake, mesh){
				if(snake.color === this.color){
					snake.maxLength++;

					animationManager.pushAnimation(mesh, [
						['rotation', {from: new V3(0,0,0), to: new V3(0,Math.PI,0)}]
					], 500, 0, function(mesh){
						renderManager.clearMesh(mesh);
					});

					return map.updateDotCount(-1);

				}else
					return false;
			},

			craftMesh : function(){
				var mat = MAT.color.clone();
				mat.uniforms.color.value = COLOR.RGB[this.color];

				return new THREE.Mesh(GEO.dot, mat);
			}
		};

		var TYPE = {
			GROUND: 0,
			WALL: 1,
			SNAKE: 2,

			SWAPERBLACK: 3,
			SWAPERGREEN: 4,
			SWAPERRED: 5,
			SWAPERYELLOW: 6,

			LIST: [
				new Block(0),
				new Block(1),
				new SnakePart(),

				new ColorSwaper( COLOR.BLACK),
				new ColorSwaper( COLOR.GREEN),
				new ColorSwaper( COLOR.RED),
				new ColorSwaper( COLOR.YELLOW),
				new ColorSwaper( COLOR.BLUE),
				new ColorSwaper( COLOR.CYAN),
				new ColorSwaper( COLOR.VIOLET),
				new ColorSwaper( COLOR.WHITE),

				new Dot( COLOR.BLACK),
				new Dot( COLOR.GREEN),
				new Dot( COLOR.RED),
				new Dot( COLOR.YELLOW),
				new Dot( COLOR.BLUE),
				new Dot( COLOR.CYAN),
				new Dot( COLOR.VIOLET),
				new Dot( COLOR.WHITE)
			]
		};
		TYPE.LIST['undefined'] = TYPE.LIST[0];


//- RENDERMANAGER
		function RenderManager(){
			this.cam = new THREE.PerspectiveCamera(FOV, window.innerWidth/window.innerHeight, 1, 100);
			this.renderer = new THREE.WebGLRenderer({antialias: false});
			this.renderer.setClearColor( 0x888888, 1);

			this.scene = new THREE.Scene();

			this.grid=[];
			this.ground=[];

			CANVAS = this.renderer.domElement;
			this.onRun = false;
			this.lastTick = 0;

			var self = this;
			window.addEventListener('resize', function(){self.updateSize();}, false);
   			this.updateSize();
		}

		RenderManager.prototype = {
			startUpdate : function(){
				this.onRun = true;
				this.lastTick = Date.now();
				this.update(this);
			},

			stopUpdate : function(){
				this.onRun = false;
			},

			update : function(rm){//rm => RenderManager
				var delta = Date.now() -rm.lastTick;
				if(delta > 40){
					delta = 40;
					rm.lastTick = Date.now();
				}

				rm.lastTick += delta;

				if(rm.onRun)
					requestAnimationFrame(function(){rm.update(rm);});

				rm.renderer.render(rm.scene, rm.cam);
				snake.update(delta);
				animationManager.update(delta);
			},

			updateSize : function(e){
				this.cam.aspect = window.innerWidth /window.innerHeight;
				this.cam.updateProjectionMatrix();

				this.renderer.setSize( window.innerWidth, window.innerHeight);

				SCREENY = window.innerHeight/2 * ( Math.cos( FOV/180*Math.PI/2 ) / Math.sin(FOV/180*Math.PI/2) );
				this.renderFrame();
			},

			initGrid : function(height, width){
				this.clearGrid();
				this.clearGround();

				this.grid = [];
				this.ground = [];

				for(var i=0, j; i<width; i++){
					this.grid.push([]);

					for(j=0; j<height; j++)
						this.grid[i].push(null);
				}

				for(var i=0, j, endI=(width>>3)+1, endJ=(height>>3)+1; i<endI; i++){
					this.ground.push([]);

					for(j=0; j<endJ; j++){
						var mat = MAT.grayGradient.clone();
						mat.attributes = {grad : {type: 'f', value: []}};

						this.ground[i].push(new THREE.Mesh(new THREE.Geometry(), mat));
						this.scene.add( this.ground[i][j] );
					}
				}
			},

			clearGrid : function(){
				for(var i=0, j=0; i<this.grid.length; i++)
					for(j=0; j<this.grid[0].length; j++)
						if(this.grid[i][j] !== null){
							this.scene.remove(this.grid[i][j]);
							this.grid[i][j] = null;
						}
			},

			craftMesh : function(type, x, y){
				if(type === undefined)
					return;

				var mesh = type.mesh.clone();
				mesh.position.x = x;
				mesh.position.z = y;

				this.grid[x][y] = mesh;
				this.scene.add(mesh);
				return mesh;
			},

			clearPos : function(x, y){
				this.scene.remove(this.grid[x][y]);
				this.grid[x][y] = null;
			},

			clearMesh : function(mesh){
				this.scene.remove(mesh);
			},

			addMesh : function(mesh){
				this.scene.add(mesh);
			},

			addGround : function(type, x, y){
				if(type.ground !== true)
					return;
				
				var ground = type.mesh.clone();
				ground.position.x = x;
				ground.position.z = y;

				x>>=3;
				y>>=3;

				THREE.GeometryUtils.merge(this.ground[x][y].geometry, ground);

				var grad = this.ground[x][y].material.attributes.grad;
				grad.value = grad.value.concat(ground.material.attributes.grad.value);
			},

			clearGround : function(){
				for(var i=0, j; i<this.ground.length; i++)
					for(j=0; j<this.ground[0].length; j++)
						if(this.ground[i][j] !== null)
							this.scene.remove(this.ground[i][j]);
			},

			renderFrame : function(){
				this.renderer.render(this.scene, this.cam);
			},

			setCamMode : function(id){
				switch(id){
					case 0:
						renderManager.cam.position.y = 4;
						renderManager.cam.position.x = 1;
						renderManager.cam.position.z = 1;
						renderManager.cam.rotation.x = -Math.PI/32*14;
						renderManager.cam.rotation.y = -Math.PI/32;
						break;
					case 1:
						renderManager.cam.position.y = 8;
						renderManager.cam.position.x = 1;
						renderManager.cam.position.z = 1;
						renderManager.cam.rotation.x = -Math.PI/2;
						renderManager.cam.rotation.y = 0;
						break;
				}



			/*
			renderManager.cam.position.y = 5;
			renderManager.cam.position.x = 1;
			renderManager.cam.position.z = 1;
			renderManager.cam.rotation.x = -Math.PI/2;//-Math.PI/32*14;
			renderManager.cam.rotation.y = -Math.PI/32;*/


			}
		};


//- BUILDER

		function Builder(){
			this.buildArea = [];
			this.height = 10;
			this.width = 10;
			this.dotCount = 0;

			this.mouse = {
				isDown : false,
				downX : 0,
				downY : 0,
				posX : 0,
				posY : 0
			};

			this.spawn = {x:0, y:0};

			this.selectNode = null;
			this.selectedColor = 0;
			this.selectedType = TYPE.GROUND;
			this.selectedId = 0;

			var rules = document.getElementById('style').sheet.cssRules;
			this.ruleGeo = rules[0].style;
			this.ruleFrame = rules[1].style;

			this.load();

			var self = this;
			this.mouseMove = function(e){
				if(!self.mouse.isDown)
					return;

				var scale = renderManager.cam.position.y /SCREENY;
				var pos = renderManager.cam.position;
				pos.x += (self.mouse.posX -e.clientX) *scale;
				pos.z += (self.mouse.posY -e.clientY) *scale;

				if(pos.x < -1)
					pos.x = -1;
				else if(pos.x > self.width+1)
					pos.x = self.width+1;

				if(pos.z < -1)
					pos.z = -1;
				else if(pos.z > self.height+1)
					pos.z = self.height+1;

				self.mouse.posX = e.clientX;
				self.mouse.posY = e.clientY;
				renderManager.renderFrame();
			};

			this.mouseDown = function(e){
				self.mouse.isDown = true;
				self.mouse.posX = self.mouse.downX = e.clientX;
				self.mouse.posY = self.mouse.downY = e.clientY;
			};

			this.mouseUp = function(e){
				if(e.target.localName === 'canvas' && self.mouse.posX === self.mouse.downX && self.mouse.posY === self.mouse.downY){
					var pos = getGridPos(self.mouse.posX, self.mouse.posY);

					if(pos.x>-1 && pos.x<self.width && pos.y>-1 && pos.y<self.height)
						self.updatePos(self.selectedId, pos.x, pos.y);
				}

				renderManager.renderFrame();
				self.mouse.isDown = false;
			};

			window.addEventListener('load', function(){
				self.bindBuildBox(self);
			}, false);
		}

		Builder.prototype = {
			bindBuildBox : function(self){
				this.selectNode = document.getElementById('craftColor').getElementsByTagName('span')[0];

				document.getElementById('craftColor').addEventListener('click', function(e){
					var color = e.target.className.split(' ')[0];

					if(COLOR[color] === undefined)
						return;

					self.selectedColor = COLOR[color];
					self.updateSelectedId();

					e.target.className = color +' select';

					if(self.selectNode !== null)
						self.selectNode.className = self.selectNode.className.split(' ')[0];

					self.selectNode = e.target;
				}, false);

				document.getElementById('craftGeo').addEventListener('click', function(e){
					var off = Math.floor(e.offsetX/60)*60;
					self.ruleFrame.left = off +'px';
					self.ruleGeo.backgroundPosition = '-'+ off +'px 0px';

					off /= 60;
					switch(off){
						case 0: case 1: self.selectedType = off;
							break;
						case 2: case 3: self.selectedType = 3 + (off-2)*8;
							break;
						case 4: self.selectedType = 2;
							break;
					}
					 
					self.updateSelectedId();
				}, false);

				self.ruleGeo.background = 'url('+ self.getBGGeo() +')';
			},

			getBGGeo : function(){
				var canvas = document.createElement('canvas');
				canvas.height = 60;
				canvas.width = 300;
				var ctx = canvas.getContext('2d');
				ctx.fillRect(0,0,300,60);

				var list = [
					['#aaa',5,40, 27,50, 54,40, 32,30],

					['#aaa',87,30, 114,20, 92,10, 65,20],
					['#888',65,20, 65,45, 87,55, 87,30],
					['#555',87,30, 87,55, 114,45, 114,20],

					['#aaa',152,30, 125,40, 137,40, 152,34],
					['#888',152,30, 152,34, 163,40, 174,40],
					['#333',174,40, 163,40, 147,46, 147,50],
					['#555',147,50, 147,46, 137,40, 125,40],

					['#aaa',204,27, 212,27, 216,23, 208,23],
					['#888',212,27, 204,27, 204,35, 212,35],
					['#555',216,23, 212,27, 212,35, 216,31],

					['#aaa',264,27, 272,27, 281,18, 273,18],
					['#888',272,27, 264,27, 264,35, 272,35],
					['#555',281,18, 272,27, 272,35, 281,26],
				];

				for(var i=0, s; i<list.length; i++){
					s = list[i];
					ctx.fillStyle =s[0];

					ctx.beginPath();
						ctx.moveTo(s[1], s[2]);
						ctx.lineTo(s[3], s[4]);
						ctx.lineTo(s[5], s[6]);
						ctx.lineTo(s[7], s[8]);
					ctx.fill();
					ctx.closePath();
				}

				return canvas.toDataURL(canvas.toDataURL());
			},

			export : function(){
				if(this.dotCount === 0)
					return 'if faut au moins 1 point';

				var list = [];
				list.push(this.height, this.width, this.spawn.x, this.spawn.y, this.dotCount&31, this.dotCount>>5);
				for(var i=0, j; i<this.buildArea.length; i++)
					for(j=0; j<this.buildArea[i].length; j++)
						list.push(this.buildArea[i][j].data);

				list[this.spawn.x *this.height +this.spawn.y  +6] = 0;
				return arrayToString(list);
			},

			load : function(data){
				if(data != null && data.indexOf(' ') === -1){
					data = stringToArray(data);

					this.height = data[0];
					this.width = data[1];
					this.spawn.x = data[2];
					this.spawn.y = data[3];

					this.dotCount = data[4]+ (data[5]<<5);

				}else{
					data = [];

					this.height = 10;
					this.width = 10;
					this.spawn.x = 0;
					this.spawn.y = 0;

					this.dotCount = 0;
				}

				for(var i=0, j; i<this.buildArea.length; i++)
					for(j=0; j<this.buildArea[i].length; j++)
						this.clearPos(this.buildArea[i][j]);

				this.buildArea = [];

				var mesh, type;
				for(var i=0, j; i<this.width; i++){
					this.buildArea.push([]);

					for(j=0; j<this.height; j++){
						type = data[i*this.height +j +6] || TYPE.GROUND;

						mesh = TYPE.LIST[ type ].mesh.clone();
						mesh.position.x = i;
						mesh.position.z = j;

						this.buildArea[i].push({data: type, meshes:[ mesh ]});

						if(type.ground !== true){
							mesh = TYPE.LIST[ TYPE.GROUND ].mesh.clone();
							mesh.position.x = i;
							mesh.position.z = j;
							this.buildArea[i][j].meshes.push(mesh);
						}
					}
				}

				this.buildArea[this.spawn.x][this.spawn.y].data = TYPE.SNAKE;

				mesh = TYPE.LIST[TYPE.SNAKE].mesh.clone();
				mesh.position.x = this.spawn.x;
				mesh.position.z = this.spawn.y;
				this.buildArea[this.spawn.x][this.spawn.y].meshes.push(mesh);
			},

			updateSelectedId : function(){
				if(this.selectedType<3)
					this.selectedId = this.selectedType;

				else
					this.selectedId = this.selectedType + this.selectedColor;
			},

			addMesh : function(id, x, y){
				var mesh = TYPE.LIST[id].mesh.clone();
				mesh.position.x = x;
				mesh.position.z = y;

				renderManager.addMesh( mesh );
				return mesh;
			},

			updatePos : function(typeId, x, y){
				if(x === this.spawn.x && y === this.spawn.y)
					return;


				this.clearPos(this.buildArea[x][y]);

				if(typeId === TYPE.WALL || typeId === TYPE.GROUND)
					this.buildArea[x][y].meshes.push( this.addMesh(typeId, x, y) );

				else{
					if(typeId === TYPE.SNAKE){
						if(this.spawn.x !== -1){
							var posA = this.buildArea[this.spawn.x][this.spawn.y];
							this.clearPos(posA);
							posA.meshes.push( this.addMesh(TYPE.GROUND, this.spawn.x, this.spawn.y) );
							posA.data = 0;
						}

						this.spawn.x = x;
						this.spawn.y = y;
					}

					this.buildArea[x][y].meshes.push(
						this.addMesh(TYPE.GROUND, x, y),
						this.addMesh(typeId, x, y)
					);
				}
				if(this.buildArea[x][y].data > 10 && this.buildArea[x][y].data < 19)
					this.dotCount--;
				if(typeId > 10 && typeId < 19)
					this.dotCount++;

				this.buildArea[x][y].data = typeId;
			},

			setSize : function(height, width){
				if(this.height < height)
					for(var i=0, j; i<this.width; i++)
						for(j=this.height; j<height; j++)
							this.buildArea[i].push({data: 0, meshes:[
									this.addMesh(TYPE.GROUND, i, j)
								]});

				else if(this.height > height)
					for(var i=0, j; i<this.width; i++){
						for(j=height; j<this.height; j++)
							this.clearPos(this.buildArea[i][j]);

						this.buildArea[i].splice(height);
					}
				
				this.height = height;

				if(this.width < width)
					for(var i=this.width, j; i<width; i++){
						this.buildArea.push([]);

						for(j=0; j<this.height; j++)
							this.buildArea[i].push({data: 0, meshes:[
									this.addMesh(TYPE.GROUND, i, j)
								]});
					}

				else if(this.width > width){
					for(var i=width, j; i<this.width; i++)
						for(j=0; j<this.buildArea[i].length; j++)
							this.clearPos(this.buildArea[i][j]);

					this.buildArea.splice(width);
				}

				this.width = width;
				renderManager.renderFrame();
			},

			clearPos : function(pos){
				for(var i=0; i<pos.meshes.length; i++)
					renderManager.clearMesh(pos.meshes[i]);
				pos.meshes.splice(0);
			},

			clearArea : function(){
				for(var i=0, j, k, pos; i<this.buildArea.length; i++)
					for(j=0; j<this.buildArea[i].length; j++)
						for(k=0; k<this.buildArea[i][j].meshes.length; k++)
							renderManager.clearMesh( this.buildArea[i][j].meshes[k] );
			},

			renderArea : function(){
				for(var i=0, j, k, meshes; i<this.buildArea.length; i++)
					for( j=0; j<this.buildArea[i].length; j++){
						meshes = this.buildArea[i][j].meshes;

						for(k=0; k<meshes.length; k++)
							renderManager.addMesh(meshes[k]);
					}
			},

			bindEvent : function(){
				window.addEventListener('mousedown', this.mouseDown, false);
				window.addEventListener('mouseup', this.mouseUp, false);
				window.addEventListener('mousemove', this.mouseMove, false);
			},

			clearEvent : function(){
				window.removeEventListener('mousedown', this.mouseDown, false);
				window.removeEventListener('mouseup', this.mouseUp, false);
				window.removeEventListener('mousemove', this.mouseMove, false);
			}
		};

		function getGridPos(x, y){
			var offY = renderManager.cam.position.y *Math.tan(  Math.atan( (y - window.innerHeight/2) /SCREENY)  );
			var offX = renderManager.cam.position.y *Math.tan(  Math.atan( (x - window.innerWidth/2) /SCREENY)  );

			return {
				x: Math.round(renderManager.cam.position.x + offX),
				y: Math.round(renderManager.cam.position.z + offY)
			};
		};


//- ACTIONMANAGER
	function ActionManager(){
		this.active = GUI.MAIN;
		this.activeNode = null;
		this.list = [];
		this.currentLevel = 0;

		var self = this;
		window.addEventListener('load',function(){self.init(self);},false);
	}

	ActionManager.prototype = {
		init : function(self){
			var levelList = document.getElementById('levelList');
			var result = "";

			for(var i=0; i<LEVELS.length; i++)
				result+="<span>"+i+"</span>";

			levelList.innerHTML = result;
			levelList.addEventListener('click', function(e){self.selectLevel(e);}, false);
			levelList.firstChild.className='active';

			var list = document.getElementsByClassName('quit');
			for(var i=0; i<list.length; i++)
				list[i].onclick = function(){self.quit();};

			this.list = [
				document.getElementById('mainMenu'),
				document.getElementById('guiPlayer'),
				document.getElementById('inGame'),
				document.getElementById('levelSelect'),
				document.getElementById('craftBox'),
				document.getElementById('craftMenu')
			];

			document.getElementsByClassName('play')[0].onclick = function(){
				renderManager.startUpdate();
				renderManager.setCamMode(0);
				self.setActive(GUI.LEVELSELECT);
			};
			document.getElementsByClassName('build')[0].onclick = function(){
				snake.setColor(COLOR.GREEN);
				renderManager.setCamMode(1);
				builder.renderArea();
				builder.bindEvent();
				renderManager.renderFrame();
				self.setActive(GUI.CRAFTBOX);
			};
			document.getElementsByClassName('clear')[0].onclick = function(){
				builder.clearArea();
				builder.load();
				builder.renderArea();
				renderManager.renderFrame();
				self.setActive(GUI.CRAFTBOX);
			};

			document.getElementsByClassName('load')[0].onclick = function(){
				builder.clearArea();
				builder.load( document.getElementById('levelData').value );
				builder.renderArea();
				renderManager.renderFrame();
				self.setActive(GUI.CRAFTBOX);
			};

			window.addEventListener('keydown', function(e){self.keyDown(e);}, false);

			document.getElementById('levelHeight').addEventListener('change', function(){
				builder.setSize(parseInt(this.value), builder.width);
			});
			document.getElementById('levelWidth').addEventListener('change', function(){
				builder.setSize(builder.height, parseInt(this.value));
			});


			snake.paused = true;
			this.activeNode = document.getElementById('mainMenu');
		},

		setActive : function(guiId){
			this.activeNode.style.display = 'none';
			this.list[guiId].style.display = '';
			this.active = guiId;
			this.activeNode = this.list[guiId];
		},

		selectLevel : function(e){
			if(e.target.localName !== 'span' || e.target.className !== 'active')
				return;

			var index = e.target.firstChild.data;
			this.currentLevel = index;
			map.updateData(LEVELS[index]);
			//TODO ANIMATION


			this.setActive(GUI.GUIPLAYER);
		},

		startNextLevel : function(){
			this.currentLevel++;
			if(LEVELS.length > this.currentLevel){
				map.updateData(LEVELS[this.currentLevel]);
				document.getElementById('levelList').childNodes[this.currentLevel].className='active';
			}else{
				console.log('end');
			}
		},

		quit : function(){
			switch(this.active){
				case GUI.CRAFTMENU:
						builder.clearArea();
						builder.clearEvent();
						renderManager.renderFrame();
					break;
				case GUI.INGAME:
						renderManager.stopUpdate();
						renderManager.clearGrid();
						renderManager.clearGround();
					break;
			}

			this.setActive(GUI.MAIN);
		},

		keyDown : function(e){
			switch(e.keyCode){
				case 90: case 87: case 38:
						if(!snake.paused)
							snake.setDir(0);
					break;

				case 83: case 40:
						if(!snake.paused)
							snake.setDir(2);
					break;

				case 81: case 65: case 37:
						if(!snake.paused)
							snake.setDir(1);
					break;

				case 68: case 39:
						if(!snake.paused)
							snake.setDir(3);
					break;

				case 80: case 27:
						switch(this.active){
							case GUI.GUIPLAYER:
									snake.paused = true;
									this.setActive(GUI.INGAME);
								break;
							case GUI.CRAFTBOX:
									document.getElementById('levelData').value = builder.export();
									this.setActive(GUI.CRAFTMENU);
								break;
							case GUI.INGAME:
									snake.paused = false;
									this.setActive(GUI.GUIPLAYER);
								break;
							case GUI.CRAFTMENU:
									this.setActive(GUI.CRAFTBOX);
						}
					break;
			}
		}
	};


//- MAIN
		var snake = new Snake();
		var map = new Map();
		var renderManager = new RenderManager();
		var animationManager = new AnimationManager();
		var builder = new Builder();
		var actionManager = new ActionManager();

		window.addEventListener('load', function(){
			document.body.insertBefore(CANVAS, document.body.firstChild);
			renderManager.cam.rotation.order = 'YXZ';
			//renderManager.renderFrame();
		}, false);

		function stringToArray(string){
			var result = [];

			for(var i=0, code; i<string.length; i++){
				code = string.charCodeAt(i);
				if(code < 97)
					result.push(code-65);
				else
					result.push(code-71);
			}

			return result;
		}

		function arrayToString(array){
			var result = "";

			for(var i=0; i<array.length; i++)
				if(array[i]<26)
					result += String.fromCharCode(array[i]+65);
				else
					result += String.fromCharCode(array[i]+71);

			return result;
		}
	</script>
</head>
<body>
	<div id='craftBox' style='display:none;'>
		<div id='craftColor'>
			<span class='BLACK select'></span>
			<span class='GREEN'></span>
			<span class='RED'></span>
			<span class='YELLOW'></span>
			<span class='BLUE'></span>
			<span class='CYAN'></span>
			<span class='VIOLET'></span>
			<span class='WHITE'></span>
		</div>
		<div id='craftGeo'>
			<span></span>
		</div>
	</div>

	<div id='guiPlayer' style='display:none;'>0</div>

	<div id='inGame' style='display:none;'>
		<button class='quit'>quitter</button>
	</div>

	<div id='mainMenu'>
		<button class='play'>jouer</button>
		<button class='build'>créer</button>
	</div>

	<div id='levelSelect' style='display:none;'>
		<div id='levelList'></div>
		<button class='quit'>quitter</button>
	</div>

	<div id='craftMenu' style='display:none;'>
		<button class='quit'>quitter</button>
		<button class='clear'>clear</button>
		<button class='load'>load</button>
		<input id='levelData' type='text'><br/>
		hauteur: <input id='levelHeight' type='number' value='10' MIN=5 MAX=30>
		largeur: <input id='levelWidth' type='number' value='10' MIN=5 MAX=30><br/>
	</div>
</body>
</html>