<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>SnakeColor</title>
	<style id='style'>
		div#craftGeo{
			background-position: -0px -0px;
			position:absolute;
			top:0px;
			left:120px;
			height:60px;
			width:60px;
			box-shadow: inset 0px 0px 1px 1px black, 0px 0px 5px black;
			transition:all 500ms;
		}

		div#craftGeo:hover span{
			left:0px;
		}

		body{
			height:0px;
			width:100%;
			cursor: default;
			margin:0px;
		}

		body div.menu{
			position:relative;
  			margin: auto;
  			border-top: solid 1px white;
  			border-bottom: solid 1px white;
  			background-color: rgba(0,0,0,.6);
  			top: 50px;
  			width: 300px;
		}

		canvas{
			position: absolute;
			top:0px;
			left:0px;
			height:100%;
			width:100%;
		}

		button{
			font-size: 2em;
			background-color: rgb(200,200,200);
			border: 0px;
			cursor: pointer;
		}

		button:hover{
			box-shadow: inset 0px 0px 15px white;

		}

		div#craftBox{
			height:60px;
			width:180px;
			box-shadow:0px 0px 5px 2px black;
		}


		div#craftGeo:hover{
			width:420px;
			background-position:0px 0px;
		}	

		div#craftGeo span{
			position: relative;
			left:0px;
			height:60px;
			width:60px;
			box-shadow: inset 0px 0px 6px 2px white, 0px 0px 2px 1px white;
			display: inline-block;
			transition:all 500ms;
		}

		div#craftColor{
			position: relative;
			height:60px;
			width:120px;
		}

		div#craftColor span{
			border:solid 1px black;
			height:28px;
			width:28px;
			box-shadow: inset 0px 0px 6px 2px black;
			margin: 0px -4px -5px 0px;
			display: inline-block;
		}

		div#craftColor span:hover{
			box-shadow: inset 0px 0px 6px 2px black, inset 0px 0px 4px 4px rgb(125,125,125);
		}
		div#craftColor span.select{
			box-shadow: inset 0px 0px 6px 2px black, inset 0px 0px 0px 5px rgb(150,150,150);
		}

		span.BLACK{ background-color:black;}
		span.GREEN{ background-color:green;}
		span.RED{ background-color:red;}
		span.YELLOW{ background-color:yellow;}
		span.BLUE{ background-color:blue;}
		span.CYAN{ background-color:cyan;}
		span.VIOLET{ background-color:magenta;}
		span.WHITE{ background-color:white;}

 /*main menu // ingame*/
  		div#mainMenu{
  			height: 100px;
  		}

  		div#mainMenu button, div#inGame button{
  			height: 90px;
			margin: 5px;
			width: 138px;
  		}
 /*level select*/
		div#levelSelect button{
  			height: 35px;
			margin: 10px 85px;
			width: 130px;
		}

		div#levelList{
			top: 25px;
			width: 270px;
			margin: auto;
		}

		div#levelList span.active{
			cursor:pointer;
			background-color:rgba(255,255,255,.5);
		}

		div#levelList span.active:hover{
			box-shadow: inset 0px 0px 15px white;
		}

		div#levelList span{
			display: inline-block;
			text-align: center;
			padding-top: 5px;
			height: 20px;
			width: 30px;
			border:solid 1px black;
			margin:3px;
			border-bottom: solid 5px black;
		}

		div#levelList span.finished{
			border-bottom: solid 5px rgb(125, 125, 125);
		}
		div#levelList span.copper{
			border-bottom: solid 5px rgb(185, 89, 0);
		}
		div#levelList span.silver{
			border-bottom: solid 5px rgb(230, 230, 230);
		}		
		div#levelList span.gold{
			border-bottom: solid 5px rgb(255, 240, 63);
		}

 /*craft menu*/
		div#craftMenu button{
			margin: 3px;
			width: 142px;
		}
		div#craftMenu input{
			font-size: 2em;
			width: 137px;
			margin: 3px;
		}
		div#craftMenu input[type="number"]{
			width: 112px;
			background-color: rgb(120,120,120);
		}
		div#craftMenu p{
			margin:0px;
			font-size: 2em;
			display: inline-block;
			text-shadow: 0px 0px 1px white,0px 0px 2px white,0px 0px 3px white;
			font-weight: bold;
		}

		div#craftMenu p.score{
			text-align: center;
			width: 172px;
		}

 /*gui player*/
		div#guiPlayer{
			position: relative;
			font-size: 3.5em;
		}

	</style>
	<script type="text/javascript" charset="UTF-8" src="three.min.js"></script>
	<script>

//- STATIC
		var SCREENY = 0,
			FOV = 75,
			V3 = THREE.Vector3,
			F3 = THREE.Face3,
			CANVAS,

			LEVELS = [
				"FFAAGAAAAAAAAAMAMAABAAMBBBMAABAAMAMAA",
				"FFCCDAAAAAAANAAAMAFAEAAAAABAGAAAOABAB",
				"HLBDFAAAAAAABAAAAABBBAAABBABAAABAABADABABADMDAABAADAABABAAABAABAAABABAALAABBALELABBBALABB",
				"LLAEUAAAAAAAAAABAANAAAAAPABAAAOAMAAAAOAAPAANAMAMAAABAABBAAABAEANAAAANAAGAFAAPAAAAAAHABAAABBOABAPAOAAAAAAAAAAAANAOAAMAABMAAAAAPAAABAAA",//154
				"FNGEKAAAAAAAAAAAAAAAAAAABNNABAMHAODAAABAMAGBEBAABAMAAODAAABAMFAABPPAAAAAAAAAA",
				"JJAEEAAAAAAABBAAAAABBBBAAAAABBAABAAABAAAAABMBAAAAAANTPAAAAAABMBAAAAABAAABAAABAAAAABAHAAAAAAAF"
			],

			GUI = {
				MAIN : 0,
				GUIPLAYER : 1,
				INGAME : 2,
				LEVELSELECT : 3,
				CRAFTBOX : 4,
				CRAFTMENU : 5
			},

			COLOR = {
				BLACK: 0,
				GREEN: 1,
				RED: 2,
				YELLOW: 3,
				BLUE: 4,
				CYAN: 5,
				VIOLET: 6,
				WHITE: 7,

				RGB:[
					new V3(0,0,0),
					new V3(1/255*40, 1/255*180, 1/255*20),
					new V3(1,0,0),
					new V3(1,1,0),
					new V3(0,0,1),
					new V3(0,1,1),
					new V3(1,0,1),
					new V3(1,1,1)
				]
			};

		var GEO = {   
			snakePart: (function(){
				var geo = new THREE.Geometry();
				geo.vertices = convertArray([
					-.4, .4, -.4,
					-.4, .4,  .4,
					 .4, .4,  .4,
					 .4, .4, -.4,

					-.4, .4, -.4,
					-.4, .0, -.4,
					-.4, .0,  .4,
					-.4, .4,  .4,

					-.4, .4,  .4,
					-.4, .0,  .4,
					 .4, .0,  .4,
					 .4, .4,  .4,

					 .4, .4,  .4,
					 .4, .0,  .4,
					 .4, .0, -.4,
					 .4, .4, -.4,

					 .4, .4, -.4,
					 .4, .0, -.4,
					-.4, .0, -.4,
					-.4, .4, -.4
				], THREE.Vector3);

				geo.faces = convertArray([
					0,1,2,    0,2,3,
					4,5,6,    4,6,7,
					8,9,10,   8,10,11,
					12,13,14, 12,14,15,
					16,17,18, 16,18,19
				], THREE.Face3);
				return geo;
			})(),

			dot: (function(){
				var geo = new THREE.Geometry();
				geo.vertices = convertArray([
					-.1, .1, -.1,
					-.1, .1,  .1, 
					 .1, .1,  .1,
					 .1, .1, -.1,

					-.1, .0, -.1,
					-.1, .0,  .1,
					 .1, .0,  .1,
					 .1, .0, -.1
				], THREE.Vector3);

				geo.faces = convertArray([
					0,1,2, 0,2,3,
					0,4,5, 0,5,1,
					1,5,6, 1,6,2,
					2,6,7, 2,7,3,
					3,7,4, 3,4,0,
					5,4,7, 5,7,6 
				], THREE.Face3);
				return geo;
			})(),

			colorSwaper: (function(){
				var geo = new THREE.Geometry();
				geo.vertices = convertArray([
					-.0, 0, -.0,
					-.0, 0,  .0, 
					 .0, 0,  .0,
					 .0, 0, -.0,

					-.2,  .1, -.2,
					-.2,  .1,  .2,
					 .2,  .1,  .2,
					 .2,  .1, -.2,

					-.4, 0, -.4,
					-.4, 0,  .4,
					 .4, 0,  .4,
					 .4, 0, -.4
				], THREE.Vector3);

				geo.faces = convertArray([
					0,4,5, 0,5,1,
					1,5,6, 1,6,2,
					2,6,7, 2,7,3,
					3,7,4, 3,4,0,

					0,5,4, 0,1,5,
					1,6,5, 1,2,6,
					2,7,6, 2,3,7,
					3,4,7, 3,0,4,

					4,8,9,   4,9,5,
					5,9,10,  5,10,6,
					6,10,11, 6,11,7,
					7,11,8,  7,8,4

				], THREE.Face3);

				return geo;
			})(),

			ground: (function(){
				var geo = new THREE.Geometry();
				geo.vertices = convertArray([
					-.4,  0, -.4,
					-.4,  0,  .4,
					 .4,  0,  .4,
					 .4,  0, -.4,

					-.4,   0, -.4,
					-.5, -.1, -.5,
					-.5, -.1,  .5,
					-.4,   0,  .4,

					-.4,   0,  .4,
					-.5, -.1,  .5,
					 .5, -.1,  .5,
					 .4,   0,  .4,

					 .4,   0,  .4,
					 .5, -.1,  .5,
					 .5, -.1, -.5,
					 .4,   0, -.4,

					 .4,   0, -.4,
					 .5, -.1, -.5,
					-.5, -.1, -.5,
					-.4,   0, -.4
				], THREE.Vector3);

				geo.faces = convertArray([
					0,1,2,    0,2,3,
					4,5,6,    4,6,7,
					8,9,10,   8,10,11,
					12,13,14, 12,14,15,
					16,17,18, 16,18,19
				], THREE.Face3);

				return geo;
			})(),

			wall: (function(){
				var geo = new THREE.Geometry();
				geo.vertices = convertArray([
					-.4,.4,-.4,  -.4,.4,.4,  .4,.4,.4,  .4,.4,-.4,

					-.4,.4,-.4,  -.5,.3,-.4,  -.5,.3,.4,  -.4,.4,.4,
					-.4,.4,.4,  -.4,.3,.5,  .4,.3,.5,  .4,.4,.4,
					.4,.4,.4,  .5,.3,.4,  .5,.3,-.4,  .4,.4,-.4,
					.4,.4,-.4,  .4,.3,-.5,  -.4,.3,-.5,  -.4,.4,-.4,

					-.4,.4,-.4, -.4,.3,-.5, -.5,.3,-.4,
					-.4,.4,.4, -.5,.3,.4, -.4,.3,.5,
					.4,.4,.4,  .4,.3,.5,  .5,.3,.4,
					.4,.4,-.4, .5,.3,-.4, .4,.3,-.5,

					-.5,.3,-.4,  -.5,-.1,-.4,  -.5,-.1,.4,  -.5,.3,.4,
					-.4,.3,.5,  -.4,-.1,.5,  .4,-.1,.5,  .4,.3,.5,
					.5,.3,.4,  .5,-.1,.4,  .5,-.1,-.4,  .5,.3,-.4,
					.4,.3,-.5,  .4,-.1,-.5,  -.4,-.1,-.5,  -.4,.3,-.5,

					-.4,.3,-.5, -.4,-.1,-.5, -.5,-.1,-.4, -.5,.3,-.4,
					 -.5,.3,.4, -.5,-.1,.4, -.4,-.1,.5, -.4,.3,.5,
					.4,.3,.5, .4,-.1,.5, .5,-.1,.4, .5,.3,.4,
					.5,.3,-.4, .5,-.1,-.4, .4,-.1,-.5, .4,.3,-.5,

					-.5,-.1,-.5, -.5,-.1,-.4, -.4,-.1,-.5,
					-.5,-.1,.5, -.4,-.1,.5, -.5,-.1,.4,
					.5,-.1,.5, .5,-.1,.4, .4,-.1,.5,
					.5,-.1,-.5, .4,-.1,-.5, .5,-.1,-.4
				], THREE.Vector3);

				geo.faces = convertArray([
					0,1,2,    0,2,3,
					4,5,6,    4,6,7,
					8,9,10,   8,10,11,
					12,13,14, 12,14,15,
					16,17,18, 16,18,19,

					20,21,22, 23,24,25,
					26,27,28, 29,30,31,

					32,33,34, 32,34,35,
					36,37,38, 36,38,39,
					40,41,42, 40,42,43,
					44,45,46, 44,46,47,

					48,49,50, 48,50,51,
					52,53,54, 52,54,55,
					56,57,58, 56,58,59,
					60,61,62, 60,62,63,

					64,65,66, 67,68,69,
					70,71,72, 73,74,75

				], THREE.Face3);

				return geo;
			})(),

			camRotatorPOS: (function(){
				var geo = new THREE.Geometry();
				geo.vertices = convertArray([
					-.4,  0, -.4,
					-.4,  0,  .4,
					 .4,  0,  .4,
					 .4,  0, -.4,

					-.4,   0, -.4,
					-.5, -.1, -.5,
					-.5, -.1,  .5,
					-.4,   0,  .4,

					-.4,   0,  .4,
					-.5, -.1,  .5,
					 .5, -.1,  .5,
					 .4,   0,  .4,

					 .4,   0,  .4,
					 .5, -.1,  .5,
					 .5, -.1, -.5,
					 .4,   0, -.4,

					 .4,   0, -.4,
					 .5, -.1, -.5,
					-.5, -.1, -.5,
					-.4,   0, -.4,

					.05, .01,-.35,
				   -.15, .01,-.15,
				    .05, .01, .05, 

				   -.05, .01, .35,
				    .15, .01, .15,
				   -.05, .01,-.05
				], THREE.Vector3);

				geo.faces = convertArray([
					0,1,2,    0,2,3,
					4,5,6,    4,6,7,
					8,9,10,   8,10,11,
					12,13,14, 12,14,15,
					16,17,18, 16,18,19,
					20,21,22, 23,24,25
				], THREE.Face3);

				return geo;
			})(),

			camRotatorNEG: (function(){
				var geo = new THREE.Geometry();
				geo.vertices = convertArray([
					-.4,  0, -.4,
					-.4,  0,  .4,
					 .4,  0,  .4,
					 .4,  0, -.4,

					-.4,   0, -.4,
					-.5, -.1, -.5,
					-.5, -.1,  .5,
					-.4,   0,  .4,

					-.4,   0,  .4,
					-.5, -.1,  .5,
					 .5, -.1,  .5,
					 .4,   0,  .4,

					 .4,   0,  .4,
					 .5, -.1,  .5,
					 .5, -.1, -.5,
					 .4,   0, -.4,

					 .4,   0, -.4,
					 .5, -.1, -.5,
					-.5, -.1, -.5,
					-.4,   0, -.4,

				   -.05, .01,-.35,
				    .15, .01,-.15,
				   -.05, .01, .05, 

				    .05, .01, .35,
				   -.15, .01, .15,
				    .05, .01,-.05
				], THREE.Vector3);

				geo.faces = convertArray([
					0,1,2,    0,2,3,
					4,5,6,    4,6,7,
					8,9,10,   8,10,11,
					12,13,14, 12,14,15,
					16,17,18, 16,18,19,
					20,22,21, 23,25,24
				], THREE.Face3);

				return geo;
			})()
		};

		var MAT = {
			snakeColor : (function(){
				var vert = [
					"#ifdef GL_ES",
					"precision mediump float;",
					"#endif",

					"attribute float saturation;",
					"varying float vSaturation;",

					"void main(){",
						"vSaturation = saturation;",
						"gl_Position = projectionMatrix *modelViewMatrix *vec4(position, 1.0);",
					"}"
				].join('\n');
				var frag = [
					"#ifdef GL_ES",
					"precision mediump float;",
					"#endif",

					"uniform vec3 color;",
					"varying float vSaturation;",

					"void main(void){",
						"gl_FragColor = vec4(color *vSaturation, 1.);",
					"}"
				].join('\n');

				return new THREE.ShaderMaterial({
					uniforms: {color : {type: 'v3', value: new V3(0,0,0)} },
					attributes: {saturation : {type: 'f', value: [
						.75, .75, .75, .75,
						  1,   1,   1,   1,
						 .9,  .9,  .9,  .9,
						 .6,  .6,  .6,  .6,
						.45, .45, .45, .45
					]} },
					vertexShader:   vert,
					fragmentShader: frag
				});
			})(),

			color : (function(){
				var vert = [
					"#ifdef GL_ES",
					"precision mediump float;",
					"#endif",

					"void main(){",
						"gl_Position = projectionMatrix *modelViewMatrix *vec4(position, 1.0);",
					"}"
				].join('\n');
				var frag = [
					"#ifdef GL_ES",
					"precision mediump float;",
					"#endif",

					"uniform vec3 color;",

					"void main(void){",
						"gl_FragColor = vec4(color, 1.);",
					"}"
				].join('\n');
				var attributes = [];

				return new THREE.ShaderMaterial({
			        uniforms: {color : {type: 'v3', value: new V3(0,0,0)} },
			        attributs : {},
			        vertexShader:   vert,
			        fragmentShader: frag
			    });
			})(),

			alphaGradient : (function(){
				var vert = [
					"#ifdef GL_ES",
					"precision mediump float;",
					"#endif",

		    		"varying float vAlpha;",
		    		"attribute float alpha;",

					"void main(){",
						"vAlpha = alpha;",
						"gl_Position = projectionMatrix *modelViewMatrix *vec4(position, 1.0);",
					"}"
				].join('\n');
				var frag = [
					"#ifdef GL_ES",
					"precision mediump float;",
					"#endif",

					"uniform vec3 color;",
		    		"varying float vAlpha;",

					"void main(void){",
						"gl_FragColor = vec4(color, vAlpha);",
					"}"
				].join('\n');
				var attributes = [];

				return new THREE.ShaderMaterial({
			        uniforms: {color : {type: 'v3', value: new V3(0,0,0)} },
			        attributes: {alpha : {type: 'f', value: [-.5,-.5,-.5,-.5, .75,.75,.75,.75, 0,0,0,0]} },
			        vertexShader:   vert,
			        fragmentShader: frag,
			        transparent: true
			    });
			})(),

			grayGradient : (function(){
				var vert = [
					"#ifdef GL_ES",
					"precision mediump float;",
					"#endif",

		    		"varying float vGrad;",
		    		"attribute float grad;",

					"void main(){",
						"vGrad = grad;",
						"gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0 );",
					"}"
				].join('\n');
				var frag = [
					"#ifdef GL_ES",
					"precision mediump float;",
					"#endif",

		    		"varying float vGrad;",

					"void main(void){",
						"gl_FragColor = vec4(vGrad, vGrad, vGrad,1.);",
					"}"
				].join('\n');
				var attributes = [];

				return new THREE.ShaderMaterial({
			        uniforms: {},
			        attributes: {
			        	grad : {type: 'f', value: []}
			        },
			        vertexShader:   vert,
			        fragmentShader: frag
			    });
			})()
		};

		function convertArray(list, type, length){
			var r = [];//result

				for(var i=0; i<list.length; i+=3)
					r.push(new type(list[i], list[i+1], list[i+2]));

			return r;
		}


//- SNAKE
		function Snake(){
			this.pos = {x: 0, y: 0};
			this.off = {x: 0, y: 0};
			this.maxLength = 5;
			this.speed = 400;
			this.nextMove = 0;
			this.moveCount = 0;
			this.paused = true;
			this.camRotation = 0;

			this.dir = -1;
			this.parts = [];
			this.color = COLOR.GREEN;
			this.mat = TYPE.LIST[ TYPE.SNAKE].mesh.material;
			this.nodeScore = null;
		}

		Snake.prototype = {
			growUp : function(){
				this.maxLength++;
			},

			setDir : function(newDir){
				newDir = (newDir + this.camRotation) %4;

				var lastPart = this.parts[this.parts.length-2];
				if(lastPart === undefined){
					this.dir = newDir;
					return;
				}

				switch(newDir){
					case 0:
							if(this.pos.x !== lastPart.x || this.pos.y !== lastPart.y+1)
								this.dir = newDir;
						break;
					case 1:
							if(this.pos.y !== lastPart.y || this.pos.x !== lastPart.x+1)
								this.dir = newDir;
						break;
					case 2:
							if(this.pos.x !== lastPart.x || this.pos.y !== lastPart.y-1)
								this.dir = newDir;
						break;
					case 3:
							if(this.pos.y !== lastPart.y || this.pos.x !== lastPart.x-1)
								this.dir = newDir;
						break;
				}
			},

			update : function(delta){
				if(this.paused)
					return;

				this.nextMove-=delta;
				if(this.nextMove>0)
					return;

				this.nextMove+=this.speed;

				switch(this.dir){
					case 0: this.pos.y--;
						break;
					case 1: this.pos.x--;
						break;
					case 2: this.pos.y++;
						break;
					case 3: this.pos.x++;
						break;
					default: return;
				}

				this.moveCount++;
				this.nodeScore.data = this.moveCount;

				if(this.parts.length > this.maxLength){
					var part = this.parts[0];
					var mesh = renderManager.grid[part.x][part.y];

					if(TYPE.BLOCK[ part.type ])
						map.setPos(part.x, part.y, TYPE.LIST[part.type]);
					else
						map.setPos(part.x, part.y, TYPE.LIST[TYPE.GROUND]);

					this.parts = this.parts.splice(1);

					animationManager.pushAnimation(mesh, [
						['position', {from: new V3(part.x, 0, part.y), to: new V3(this.parts[0].x, 0, this.parts[0].y)}],
						['scale', {from: new V3(1,1,1), to: new V3(.1,.1,.1)}]
					], this.speed, 0,
					function(mesh){renderManager.clearMesh(mesh);});
				}

				if(map.moveIn(this)){
					var lastPart = this.parts[this.parts.length-1];

					var mesh = renderManager.craftMesh(TYPE.LIST[TYPE.SNAKE], this.pos.x, this.pos.y);
					var vx = (this.dir === 1 ? 1 : this.dir === 3 ? -1 : 0);
					var vz = (this.dir === 0 ? 1 : this.dir === 2 ? -1 : 0);

					animationManager.pushAnimation(mesh, [
						['position', {from: new V3(this.pos.x +vx *.6, 0, this.pos.y +vz *.6), to: mesh.position.clone()}],
						['scale', {from: new V3(.1,.1,.1), to: new V3(1,1,1)}]
					], this.speed*.75, 0);

					var camP = renderManager.cam.position.clone();

					animationManager.pushAnimation(renderManager.cam, [
						['position', {from: camP, to: new V3(this.pos.x+this.off.x, camP.y, this.pos.y+this.off.y)}]
					], this.speed, 0);

					this.parts.push({x: this.pos.x, y: this.pos.y, type: map.getType(this.pos)});
					map.setPos(this.pos.x, this.pos.y, TYPE.LIST[TYPE.SNAKE]);
				}else
					map.reset();
			},

			setColor : function(color){
					snake.color = color;
					snake.mat.uniforms.color.value = COLOR.RGB[ color];
			},

			setCamRotation : function(id){
				var newR, newP;

				switch(id){
					case 0:
							this.camRotation = 0;
							renderManager.cam.rotation.y %= Math.PI*2;
							newR = new V3(-Math.PI/32*12, -Math.PI/16, 0);
						break;
					case 1:
							newR = new V3(-Math.PI/32*12, renderManager.cam.rotation.y +Math.PI/2, 0);
						break;
					case -1:
							newR = new V3(-Math.PI/32*12, renderManager.cam.rotation.y -Math.PI/2, 0);
						break;
					default: return;
				}

				this.camRotation += id;
				if(this.camRotation < 0)
					this.camRotation+=4;
				this.camRotation %= 4;

				switch(this.camRotation){
					case 0: newP = new V3(this.pos.x-.5, 4, this.pos.y+2);
						break;
					case 1: newP = new V3(this.pos.x+2, 4,  this.pos.y+.5);
						break;
					case 2: newP = new V3(this.pos.x+.5, 4, this.pos.y-2);
						break;
					case 3: newP = new V3(this.pos.x-2, 4,  this.pos.y-.5);
						break;
				}

				this.off.x = newP.x -this.pos.x;
				this.off.y = newP.z -this.pos.y;

				animationManager.pushAnimation(renderManager.cam, [
						['position', {from: renderManager.cam.position.clone(), to: newP}],
						['rotation', {from: renderManager.cam.rotation.clone(), to: newR}]
					], 500, 0);
			},

			reset : function(){
				this.moveCount = 0;
				this.maxLength = 5;
				this.parts = [map.spawn];
				this.dir = -1;

				this.pos.x = map.spawn.x;
				this.pos.y = map.spawn.y;

				this.setColor(COLOR.GREEN);
				this.setCamRotation(0);

				var mesh = renderManager.craftMesh(TYPE.LIST[TYPE.SNAKE], map.spawn.x, map.spawn.y);

				animationManager.pushAnimation(mesh, [
					['scale', {from: new V3(.05,.05,.05), to: new V3(1,1,1)}]
				],400, 0);

				map.grid[map.spawn.x][map.spawn.y] = TYPE.LIST[TYPE.SNAKE];
				snake.paused = false;
			}
		};


//- MAP
		function Map(){
			this.currentData = null;
			this.grid = [];
			this.ld = {};

			this.height = 0;
			this.width = 0;

			this.dotCount = 0;
			this.gold = 0;
			this.silver = 0;
			this.copper = 0;

			this.spawn = {x: 0, y: 0};
		}

		Map.prototype = {
			updateData : function(ld){
				var result = stringToArray(ld);
				this.ld = result;

				this.height = result[0];
				this.width = result[1];
				this.spawn = {x: result[2]+1, y: result[3]+1};

				this.dotCount = result[4]+ (result[5]<<5);
				this.gold =  result[6]+ (result[7]<<5);
				this.silver =  result[8]+ (result[9]<<5);
				this.copper =  result[10]+ (result[11]<<5);

				renderManager.initGrid(this.height+2, this.width+2);

				this.grid = [];
				for(var i=-1, endI=this.width+1, endJ=this.height+1, length, select;  i<endI;  i++){
					this.grid.push([]);

					length = this.grid.length-1;

					for(var j=-1; j<endJ; j++){
						if(i<0 || j<0 || i>=this.width || j>=this.height)
							select = TYPE.LIST[ TYPE.WALL ];
						else
							select = TYPE.LIST[ result[i *map.height +j +12] ];


						if(select !== undefined){
							if(select.ground === true)
								renderManager.addGround(select, i+1, j+1);

							else{
								renderManager.craftMesh(select, i+1, j+1);
								renderManager.addGround(TYPE.LIST[TYPE.GROUND], i+1, j+1);
							}

							this.grid[i+1].push(select);

						}else{
							this.grid[i+1].push(TYPE.LIST[TYPE.GROUND]);
							renderManager.addGround(TYPE.LIST[TYPE.GROUND], i+1, j+1);
						}
					}
				}

				snake.reset();
			},

			moveIn : function(snake){
				return this.grid[snake.pos.x][snake.pos.y].moveIn(snake, renderManager.grid[snake.pos.x][snake.pos.y]);
			},

			getType : function(pos){
				return this.grid[pos.x][pos.y].id;
			},

			setPos : function(x, y, type){
				this.grid[x][y] = type;
			},

			updateDotCount : function(offset){
				this.dotCount += offset;

				if(this.dotCount <= 0){

					actionManager.startNextLevel();
					return false;
				}

				return true;
			},

			reset : function(){
				snake.paused = true;
				snake.dir = -1;

				this.dotCount = this.ld[4];

				for(var i= (snake.parts.length>25 ? snake.parts.length-25 : 0); i<snake.parts.length; i++){
					var mesh = renderManager.grid[snake.parts[i].x][snake.parts[i].y];

					animationManager.pushAnimation(mesh, [
						['rotation', {from: new V3(0,0,0), to: new V3(0, Math.PI*1.5, 0)}],
						['scale', {from: new V3(1,1,1), to: new V3(0.05, 0.05, 0.05)}]
					], 400, i*50,
					function(mesh){renderManager.clearMesh(mesh);});
				}

				setTimeout( function(){
						renderManager.clearGrid();

						for(var i=0, j; i<map.width; i++)
							for(var j=0; j<map.height; j++){
								select = TYPE.LIST[ map.ld[i *map.height +j +12] ];

								if(select !== undefined)
									if(select.ground !== true){
										renderManager.craftMesh(select, i+1, j+1);
										map.grid[i+1][j+1] = select;

									}else{
										renderManager.clearPos(i+1, j+1);
										map.grid[i+1][j+1] = select;
									}
							}

						snake.reset();
					}, Math.min(25, snake.parts.length) *50+200);
			}
		};


//- ANIMATION
		function AnimationManager(){
			this.list = [];
		}

		AnimationManager.prototype = {
			pushAnimation : function(mesh, param, duration, delay, callback){
				if(mesh != null)
					this.list.push(new Animation(mesh, param, duration, delay, callback));
			},

			update : function(delta){
				for(var i=0; i<this.list.length; i++)
					if(this.list[i].update(delta)){
						this.list.splice(i,1);
						i--;
					}
			}
		};

		function Animation(mesh, param, duration, delay, callback){
			this.mesh = mesh;
			this.param = param;
			this.duration = duration;
			this.delay = delay || 0;
			this.callback = callback;

			if(this.delay === 0)
				for(var i=0; i<this.param.length; i++)
					this.mesh[this.param[i][0]].set(
						this.param[i][1].from.x,
						this.param[i][1].from.y,
						this.param[i][1].from.z
					);
		}

		Animation.prototype = {
			update : function(delta){
				this.delay -= delta;

				if(this.delay>0)
					return;

				var off = -this.delay/ this.duration;

				if(off>1)
					off = 1;

				var offN = 1-off;

				for(var i=0; i<this.param.length; i++)
					this.mesh[this.param[i][0]].set(
						this.param[i][1].from.x *offN + this.param[i][1].to.x *off,
						this.param[i][1].from.y *offN + this.param[i][1].to.y *off,
						this.param[i][1].from.z *offN + this.param[i][1].to.z *off
					);

				if(off === 1){
					if(this.callback)
						this.callback(this.mesh);
					return true;
				}

				return false;
			}
		};


//- ENTITIES CONSTRUCTOR + STATIC
		function SnakePart(id){
			this.id = id;
			this.color;
			this.mesh = this.craftMesh();
		}

		SnakePart.prototype = {
			moveIn : function(){
				return false;
			},

			craftMesh : function(){
				var mat = MAT.snakeColor.clone();
				this.color = mat.uniforms.color.value = COLOR.RGB[ COLOR.GREEN ];

				return new THREE.Mesh(GEO.snakePart, mat);
			}
		};


		function ColorSwaper(id, color, pos){
			this.id = id;
			this.color = color;
			this.mesh = this.craftMesh();
		}

		ColorSwaper.prototype =	{
			moveIn : function(snake, mesh){
				snake.setColor(this.color);

				animationManager.pushAnimation(mesh, [
						['scale', {from: new V3(1,1,1), to: new V3(.05,.05,.05)}]
					], 500, 0, function(mesh){
						renderManager.clearMesh(mesh);
					});

				return true;
			},

			craftMesh : function(){
				var mat = MAT.alphaGradient.clone();
				mat.uniforms.color.value = COLOR.RGB[this.color];

				return new THREE.Mesh(GEO.colorSwaper, mat);
			}
		};

		function Block(id, type){
			this.id = id;
			this.type = type;
			this.mesh = this.craftMesh();
			this.ground = true;
		}

		Block.prototype = {
			moveIn : function(snake){
				if(this.type !== 0)
					snake.setCamRotation(this.type);

				return this.type !== 2;
			},

			craftMesh : function(){
				var mat = MAT.grayGradient.clone(),
					geo;

				if(this.type === 0){
					geo = GEO.ground;
					mat.attributes = {grad: {type:'f', value:[.35,.35,.35,.35, .45,.45,.45,.45, .40,.40,.40,.40, .3,.3,.3,.3, .25,.25,.25,.25]}};

				}else if (this.type === 2){
					geo = GEO.wall;
					mat.attributes = {grad: {type:'f', value:[
						.25,.25,.25,.25,

						.35,.35,.35,.35,
						.30,.30,.30,.30,
						.2,.2,.2,.2,
						.15,.15,.15,.15,

						.25,.25,.25,
						.325,.325,.325,
						.25,.25,.25,
						.175,.175,.175,

						.4,.4,.4,.4,
						.35,.35,.35,.35,
						.25,.25,.25,.25,
						.2,.2,.2,.2,

						.3,.3,.3,.3,
						.375,.375,.375,.375,
						.3,.3,.3,.3,
						.225,.225,.225,.225,

						.35,.35,.35,
						.35,.35,.35,
						.35,.35,.35,
						.35,.35,.35
					]}};
				}else{
					geo = (this.type === 1 ? GEO.camRotatorPOS : GEO.camRotatorNEG);
					mat.attributes = {grad: {type:'f', value:[
						.35,.35,.35,.35, .45,.45,.45,.45, .40,.40,.40,.40, .3,.3,.3,.3, .25,.25,.25,.25,
						.1,.1,.1,
						.1,.1,.1
					]}};
				}

				return new THREE.Mesh(geo, mat);
			}
		};

		function Dot(id, color){
			this.id = id;
			this.color = color;
			this.mesh = this.craftMesh();
		}

		Dot.prototype = {
			moveIn : function(snake, mesh){
				if(snake.color === this.color){
					snake.maxLength++;

					animationManager.pushAnimation(mesh, [
						['rotation', {from: new V3(0,0,0), to: new V3(0,Math.PI,0)}]
					], 500, 0, function(mesh){
						renderManager.clearMesh(mesh);
					});

					return map.updateDotCount(-1);

				}else
					return false;
			},

			craftMesh : function(){
				var mat = MAT.color.clone();
				mat.uniforms.color.value = COLOR.RGB[this.color];

				return new THREE.Mesh(GEO.dot, mat);
			}
		};

		var TYPE = {
			GROUND: 0,
			WALL: 1,
			CAMROTATORPOS: 19,
			CAMROTATORNEG: 20,
			BLOCK : {0:1, 1:1, 19:1, 20:1},

			SNAKE: 2,

			SWAPERBLACK: 3,
			SWAPERGREEN: 4,
			SWAPERRED: 5,
			SWAPERYELLOW: 6,
			SWAPERBLUE: 7,
			SWAPERCYAN: 8,
			SWAPERVIOLET: 9,
			SWAPERWHITE: 10,
			SWAPER: {3:1, 4:1, 5:1, 6:1, 7:1, 8:1, 9:1, 10:1},

			DOTBLACK: 11,
			DOTGREEN: 12,
			DOTRED: 13,
			DOTYELLOW: 14,
			DOTBLUE: 15,
			DOTCYAN: 16,
			DOTVIOLET: 17,
			DOTWHITE: 18,
			DOT : {11:1, 12:1, 13:1, 14:1, 15:1, 16:1, 17:1, 18:1},

			LIST: [
				new Block(0, 0),
				new Block(1, 2),
				new SnakePart(2),

				new ColorSwaper(3, COLOR.BLACK),
				new ColorSwaper(4, COLOR.GREEN),
				new ColorSwaper(5, COLOR.RED),
				new ColorSwaper(6, COLOR.YELLOW),
				new ColorSwaper(7, COLOR.BLUE),
				new ColorSwaper(8, COLOR.CYAN),
				new ColorSwaper(9, COLOR.VIOLET),
				new ColorSwaper(10, COLOR.WHITE),

				new Dot(11, COLOR.BLACK),
				new Dot(12, COLOR.GREEN),
				new Dot(13, COLOR.RED),
				new Dot(14, COLOR.YELLOW),
				new Dot(15, COLOR.BLUE),
				new Dot(16, COLOR.CYAN),
				new Dot(17, COLOR.VIOLET),
				new Dot(18, COLOR.WHITE),

				new Block(19, 1),
				new Block(20,-1)
			]
		};
		TYPE.LIST['undefined'] = TYPE.LIST[0];


//- RENDERMANAGER
		function RenderManager(){
			this.cam = new THREE.PerspectiveCamera(FOV, window.innerWidth/window.innerHeight, 1, 100);
			this.renderer = new THREE.WebGLRenderer({antialias: true});
			this.renderer.setClearColor( 0x888888, 1);

			this.scene = new THREE.Scene();

			this.grid=[];
			this.ground=[];

			CANVAS = this.renderer.domElement;
			this.onRun = false;
			this.lastTick = 0;

			var self = this;
			window.addEventListener('resize', function(){self.updateSize();}, false);
   			this.updateSize();
		}

		RenderManager.prototype = {
			startUpdate : function(){
				this.onRun = true;
				this.lastTick = Date.now();
				this.update(this);
			},

			stopUpdate : function(){
				this.onRun = false;
			},

			update : function(rm){//rm => RenderManager
				var delta = Date.now() -rm.lastTick;
				if(delta > 40){
					delta = 40;
					rm.lastTick = Date.now();
				}

				rm.lastTick += delta;

				if(rm.onRun)
					requestAnimationFrame(function(){rm.update(rm);});

				rm.renderer.render(rm.scene, rm.cam);
				snake.update(delta);
				animationManager.update(delta);
			},

			updateSize : function(e){
				this.cam.aspect = window.innerWidth /window.innerHeight;
				this.cam.updateProjectionMatrix();

				this.renderer.setSize( window.innerWidth*.80, window.innerHeight*.80);

				SCREENY = window.innerHeight/2 * ( Math.cos( FOV/180*Math.PI/2 ) / Math.sin(FOV/180*Math.PI/2) );
				this.renderFrame();
			},

			initGrid : function(height, width){
				this.clearGrid();
				this.clearGround();

				this.grid = [];
				this.ground = [];

				for(var i=0, j; i<width; i++){
					this.grid.push([]);

					for(j=0; j<height; j++)
						this.grid[i].push(null);
				}

				var mat = MAT.grayGradient.clone();
				mat.attributes = {grad : {type: 'f', value: []}};

				this.ground.push(new THREE.Mesh(new THREE.Geometry(), mat));
				this.scene.add( this.ground[0]);

			},

			clearGrid : function(){
				for(var i=0, j=0; i<this.grid.length; i++)
					for(j=0; j<this.grid[0].length; j++)
						if(this.grid[i][j] !== null){
							this.scene.remove(this.grid[i][j]);
							this.grid[i][j] = null;
						}
			},

			craftMesh : function(type, x, y){
				if(type === undefined)
					return;

				var mesh = type.mesh.clone();
				mesh.position.x = x;
				mesh.position.z = y;

				this.grid[x][y] = mesh;
				this.scene.add(mesh);
				return mesh;
			},

			clearPos : function(x, y){
				this.scene.remove(this.grid[x][y]);
				this.grid[x][y] = null;
			},

			clearMesh : function(mesh){
				this.scene.remove(mesh);
			},

			addMesh : function(mesh){
				this.scene.add(mesh);
			},

			addGround : function(type, x, y){
				if(type.ground !== true)
					return;
				
				var ground = type.mesh.clone();
				ground.position.x = x;
				ground.position.z = y;
				THREE.GeometryUtils.merge(this.ground[0].geometry, ground);

				var grad = this.ground[0].material.attributes.grad;
				grad.value = grad.value.concat(ground.material.attributes.grad.value);
			},

			clearGround : function(){
				this.scene.remove(this.ground[0]);
			},

			renderFrame : function(){
				this.renderer.render(this.scene, this.cam);
			},

			setCamMode : function(id){
				switch(id){
					case 0:
							snake.setCamRotation(0);
						break;
					case 1:
							renderManager.cam.position.set(1, 8, 1);
							renderManager.cam.rotation.set(-Math.PI/2, 0, 0);
						break;
				}
			}
		};


//- BUILDER

		function Builder(){
			this.buildArea = [];
			this.height = 10;
			this.width = 10;

			this.dotCount = 0;
			this.gold = 0;
			this.silver = 0;
			this.copper = 0;

			this.spawn = {x:0, y:0};

			this.mouse = {
				isDown : false,
				downX : 0,
				downY : 0,
				posX : 0,
				posY : 0
			};

			this.selectNode = null;
			this.selectedColor = 0;
			this.selectedType = TYPE.GROUND;
			this.selectedId = 0;

			var rules = document.getElementById('style').sheet.cssRules;
			this.ruleGeo = rules[0].style;
			this.ruleFrame = rules[1].style;

			this.load("");

			var self = this;
			this.mouseMove = function(e){
				if(!self.mouse.isDown)
					return;

				var scale = renderManager.cam.position.y /SCREENY;
				var pos = renderManager.cam.position;
				pos.x += (self.mouse.posX -e.clientX) *scale;
				pos.z += (self.mouse.posY -e.clientY) *scale;

				if(pos.x < -1)
					pos.x = -1;
				else if(pos.x > self.width+1)
					pos.x = self.width+1;

				if(pos.z < -1)
					pos.z = -1;
				else if(pos.z > self.height+1)
					pos.z = self.height+1;

				self.mouse.posX = e.clientX;
				self.mouse.posY = e.clientY;
				renderManager.renderFrame();
			};

			this.mouseDown = function(e){
				self.mouse.isDown = true;
				self.mouse.posX = self.mouse.downX = e.clientX;
				self.mouse.posY = self.mouse.downY = e.clientY;
			};

			this.mouseUp = function(e){
				if(e.target.localName === 'canvas' && self.mouse.posX === self.mouse.downX && self.mouse.posY === self.mouse.downY){
					var pos = getGridPos(self.mouse.posX, self.mouse.posY);

					if(pos.x>-1 && pos.x<self.width && pos.y>-1 && pos.y<self.height)
						self.updatePos(self.selectedId, pos.x, pos.y);
				}

				renderManager.renderFrame();
				self.mouse.isDown = false;
			};

			window.addEventListener('load', function(){
				self.bindBuildBox(self);
			}, false);
		}

		Builder.prototype = {
			bindBuildBox : function(self){
				this.selectNode = document.getElementById('craftColor').getElementsByTagName('span')[0];

				document.getElementById('craftColor').addEventListener('click', function(e){
					var color = e.target.className.split(' ')[0];

					if(COLOR[color] === undefined)
						return;

					self.selectedColor = COLOR[color];
					self.updateSelectedId();

					e.target.className = color +' select';

					if(self.selectNode !== null)
						self.selectNode.className = self.selectNode.className.split(' ')[0];

					self.selectNode = e.target;
				}, false);

				document.getElementById('craftGeo').addEventListener('click', function(e){
					var off = Math.floor(e.offsetX/60)*60;
					self.ruleFrame.left = off +'px';
					self.ruleGeo.backgroundPosition = '-'+ off +'px 0px';

					off /= 60;
					switch(off){
						case 0: case 1: self.selectedType = off;
							break;
						case 2: case 3: self.selectedType = 3 + (off-2)*8;
							break;
						case 4: self.selectedType = 2;
							break;
						case 5: case 6: self.selectedType = off +14;
							break;
					}
					 
					self.updateSelectedId();
				}, false);

				self.ruleGeo.background = 'url('+ self.getBGGeo() +')';
			},

			getBGGeo : function(){
				var canvas = document.createElement('canvas');
				canvas.height = 60;
				canvas.width = 420;
				var ctx = canvas.getContext('2d');
				ctx.fillRect(0,0,420,60);

				var list = [
					['#aaa',5,40, 27,50, 54,40, 32,30],

					['#aaa',87,30, 114,20, 92,10, 65,20],
					['#888',65,20, 65,45, 87,55, 87,30],
					['#555',87,30, 87,55, 114,45, 114,20],

					['#aaa',152,30, 125,40, 137,40, 152,34],
					['#888',152,30, 152,34, 163,40, 174,40],
					['#333',174,40, 163,40, 147,46, 147,50],
					['#555',147,50, 147,46, 137,40, 125,40],

					['#aaa',204,27, 212,27, 216,23, 208,23],
					['#888',212,27, 204,27, 204,35, 212,35],
					['#555',216,23, 212,27, 212,35, 216,31],

					['#aaa',264,27, 272,27, 281,18, 273,18],
					['#888',272,27, 264,27, 264,35, 272,35],
					['#555',281,18, 272,27, 272,35, 281,26],

					['#aaa',332,4, 318,18, 332,32, 328,18],
					['#888',327,27, 331,41, 327,55, 341,41],

					['#aaa',388,4, 402,18, 388,32, 392,18],
					['#888',393,27, 389,41, 393,55, 379,41]
				];

				for(var i=0, s; i<list.length; i++){
					s = list[i];
					ctx.fillStyle =s[0];

					ctx.beginPath();
						ctx.moveTo(s[1], s[2]);
						ctx.lineTo(s[3], s[4]);
						ctx.lineTo(s[5], s[6]);
						ctx.lineTo(s[7], s[8]);
					ctx.fill();
					ctx.closePath();
				}

				return canvas.toDataURL(canvas.toDataURL());
			},

			export : function(){
				if(this.dotCount === 0)
					return '-----';

				var list = [
					this.height, this.width, 
					this.spawn.x, this.spawn.y, 
					this.dotCount&31, this.dotCount>>5,
					this.gold&31, this.gold>>5,
					this.silver&31, this.silver>>5,
					this.copper&31, this.copper>>5
				];

				for(var i=0, j; i<this.buildArea.length; i++)
					for(j=0; j<this.buildArea[i].length; j++)
						list.push(this.buildArea[i][j].data);

				list[this.spawn.x *this.height +this.spawn.y  +12] = 0;
				return arrayToString(list);
			},

			load : function(data){
				if(data !== "" && data.indexOf('-') === -1){
					data = stringToArray(data);

					this.height = data[0];
					this.width = data[1];
					this.spawn.x = data[2];
					this.spawn.y = data[3];

					this.dotCount = data[4]+ (data[5]<<5);
					this.gold = data[6]+ (data[7]<<5);
					this.silver = data[8]+ (data[9]<<5);
					this.copper = data[10]+ (data[11]<<5);

				}else{
					data = [];

					this.height = 10;
					this.width = 10;
					this.spawn.x = 0;
					this.spawn.y = 0;

					this.dotCount = 0;
					this.gold = 0;
					this.silver = 0;
					this.copper = 0;
				}

				this.setSize(this.height, this.width);

				for(var i=0, j; i<this.buildArea.length; i++)
					for(j=0; j<this.buildArea[i].length; j++)
						this.clearPos(this.buildArea[i][j]);

				this.buildArea = [];

				var mesh, type;
				for(var i=0, j; i<this.width; i++){
					this.buildArea.push([]);

					for(j=0; j<this.height; j++){
						type = data[i*this.height +j +12] || TYPE.GROUND;

						mesh = TYPE.LIST[ type ].mesh.clone();
						mesh.position.x = i;
						mesh.position.z = j;

						this.buildArea[i].push({data: type, meshes:[ mesh ]});

						if(type.ground !== true){
							mesh = TYPE.LIST[ TYPE.GROUND ].mesh.clone();
							mesh.position.x = i;
							mesh.position.z = j;
							this.buildArea[i][j].meshes.push(mesh);
						}
					}
				}

				this.buildArea[this.spawn.x][this.spawn.y].data = TYPE.SNAKE;

				mesh = TYPE.LIST[TYPE.SNAKE].mesh.clone();
				mesh.position.x = this.spawn.x;
				mesh.position.z = this.spawn.y;
				this.buildArea[this.spawn.x][this.spawn.y].meshes.push(mesh);
			},

			updateSelectedId : function(){
				if(this.selectedType<3)
					this.selectedId = this.selectedType;
				else
					this.selectedId = this.selectedType + this.selectedColor;
			},

			addMesh : function(id, x, y){
				var mesh = TYPE.LIST[id].mesh.clone();
				mesh.position.x = x;
				mesh.position.z = y;

				renderManager.addMesh( mesh );
				return mesh;
			},

			updatePos : function(typeId, x, y){
				if(x === this.spawn.x && y === this.spawn.y)
					return;

				this.clearPos(this.buildArea[x][y]);

				if(TYPE.BLOCK[typeId])
					this.buildArea[x][y].meshes.push( this.addMesh(typeId, x, y) );

				else{
					if(typeId === TYPE.SNAKE){
						if(this.spawn.x !== -1){
							var posA = this.buildArea[this.spawn.x][this.spawn.y];
							this.clearPos(posA);
							posA.meshes.push( this.addMesh(TYPE.GROUND, this.spawn.x, this.spawn.y) );
							posA.data = 0;
						}

						this.spawn.x = x;
						this.spawn.y = y;
					}

					this.buildArea[x][y].meshes.push(
						this.addMesh(TYPE.GROUND, x, y),
						this.addMesh(typeId, x, y)
					);
				}

				this.updateDotCount(typeId, x, y);
				this.buildArea[x][y].data = typeId;
			},

			updateDotCount : function(typeId, x, y){
				if(TYPE.DOT[this.buildArea[x][y].data])
					this.dotCount--;
				if(TYPE.DOT[typeId])
					this.dotCount++;
			},

			setSize : function(height, width){
				if(this.height < height)
					for(var i=0, j; i<this.width; i++)
						for(j=this.height; j<height; j++)
							this.buildArea[i].push({data: 0, meshes:[
									this.addMesh(TYPE.GROUND, i, j)
								]});

				else if(this.height > height)
					for(var i=0, j; i<this.width; i++){
						for(j=height; j<this.height; j++){
							this.updateDotCount(TYPE.GROUND, i, j);
							this.clearPos(this.buildArea[i][j]);
						}

						this.buildArea[i].splice(height);
					}
				
				this.height = height;

				if(this.width < width)
					for(var i=this.width, j; i<width; i++){
						this.buildArea.push([]);

						for(j=0; j<this.height; j++)
							this.buildArea[i].push({data: 0, meshes:[
									this.addMesh(TYPE.GROUND, i, j)
								]});
					}

				else if(this.width > width){
					for(var i=width, j; i<this.width; i++)
						for(j=0; j<this.buildArea[i].length; j++){
							this.updateDotCount(TYPE.GROUND, i, j);
							this.clearPos(this.buildArea[i][j]);
						}

					this.buildArea.splice(width);
				}

				this.width = width;
				renderManager.renderFrame();
			},

			clearPos : function(pos){
				for(var i=0; i<pos.meshes.length; i++)
					renderManager.clearMesh(pos.meshes[i]);
				pos.meshes.splice(0);
			},

			clearArea : function(){
				for(var i=0, j, k, pos; i<this.buildArea.length; i++)
					for(j=0; j<this.buildArea[i].length; j++)
						for(k=0; k<this.buildArea[i][j].meshes.length; k++)
							renderManager.clearMesh( this.buildArea[i][j].meshes[k] );
			},

			renderArea : function(){
				for(var i=0, j, k, meshes; i<this.buildArea.length; i++)
					for( j=0; j<this.buildArea[i].length; j++){
						meshes = this.buildArea[i][j].meshes;

						for(k=0; k<meshes.length; k++)
							renderManager.addMesh(meshes[k]);
					}
			},

			bindEvent : function(){
				window.addEventListener('mousedown', this.mouseDown, false);
				window.addEventListener('mouseup', this.mouseUp, false);
				window.addEventListener('mousemove', this.mouseMove, false);
			},

			clearEvent : function(){
				window.removeEventListener('mousedown', this.mouseDown, false);
				window.removeEventListener('mouseup', this.mouseUp, false);
				window.removeEventListener('mousemove', this.mouseMove, false);
			}
		};

		function getGridPos(x, y){
			var offY = renderManager.cam.position.y *Math.tan(  Math.atan( (y - window.innerHeight/2) /SCREENY)  );
			var offX = renderManager.cam.position.y *Math.tan(  Math.atan( (x - window.innerWidth/2) /SCREENY)  );

			return {
				x: Math.round(renderManager.cam.position.x + offX),
				y: Math.round(renderManager.cam.position.z + offY)
			};
		};


//- ACTIONMANAGER
	function ActionManager(){
		this.active = GUI.MAIN;
		this.activeNode = null;
		this.list = [];
		this.currentLevel = 0;

		var self = this;
		window.addEventListener('load',function(){self.init(self);},false);
	}

	ActionManager.prototype = {
		init : function(self){
			var levelList = document.getElementById('levelList');
			var result = "";

			for(var i=0, achived="finished active", lvl, s; i<LEVELS.length; i++){
				if(save[i] === undefined)
					save.push(0);

				s = save[i*2]+(save[i*2+1]<<5);

				if(s !== 0){
					lvl = stringToArray(LEVELS[i].slice(6,12));

					if(lvl[0] +(lvl[1]<<5) > s)
						achived = 'gold';

					else if(lvl[2] +(lvl[3]<<5) > s)
						achived = 'silver';

					else if(lvl[4] +(lvl[5]<<5) > s)
						achived = 'copper';

					else
						achived = 'finished';

					achived += ' active';

				}else if(achived.length > 8)
					achived = 'active';

				else
					achived = '';

				result+="<span title='"+s+"' class='"+achived+"'>"+i+"</span>";
			}

			levelList.innerHTML = result;
			levelList.addEventListener('click', function(e){self.selectLevel(e);}, false);

			this.list = [
				document.getElementById('mainMenu'),
				document.getElementById('guiPlayer'),
				document.getElementById('inGame'),
				document.getElementById('levelSelect'),
				document.getElementById('craftBox'),
				document.getElementById('craftMenu')
			];

			document.getElementsByClassName('quit')[0].onclick = function(){
				self.setActive(GUI.MAIN, 0);
			};
			document.getElementsByClassName('quit')[1].onclick = function(){
				self.setActive(GUI.MAIN, 1);
			};
			document.getElementsByClassName('quit')[2].onclick = function(){
				self.setActive(GUI.MAIN, 2);
			};

			document.getElementsByClassName('play')[0].onclick = function(){
				self.setActive(GUI.LEVELSELECT);
			};

			document.getElementsByClassName('build')[0].onclick = function(){
				self.setActive(GUI.CRAFTBOX, 0);
			};
			document.getElementsByClassName('clear')[0].onclick = function(){
				self.setActive(GUI.CRAFTBOX, 1);
			};
			document.getElementsByClassName('load')[0].onclick = function(){
				self.setActive(GUI.CRAFTBOX, 2);
			};

			document.getElementsByClassName('resume')[0].onclick = function(){
				self.setActive(GUI.GUIPLAYER);
			};

			window.addEventListener('keydown', function(e){self.keyDown(e);}, false);

			document.getElementById('levelHeight').addEventListener('change', function(){
				var value = checkInput(this, parseInt(this.value));
				builder.setSize(value, builder.width);
			});

			document.getElementById('levelWidth').addEventListener('change', function(){
				var value = checkInput(this, parseInt(this.value));
				builder.setSize(builder.height, value);
			});

			document.getElementById('gold').addEventListener('change', function(){
				builder.gold = checkInput(this, parseInt(this.value));
			});
			document.getElementById('silver').addEventListener('change', function(){
				builder.silver = checkInput(this, parseInt(this.value));
			});
			document.getElementById('copper').addEventListener('change', function(){
				builder.copper = checkInput(this, parseInt(this.value));
			});

			snake.paused = true;
			this.activeNode = document.getElementById('mainMenu');
		},

		setActive : function(guiId, id){
			switch(guiId){
				case GUI.LEVELSELECT:
					renderManager.startUpdate();
					renderManager.setCamMode(0);

				break;
				case GUI.CRAFTBOX:
					if(id === 0){
							snake.setColor(COLOR.GREEN);
							renderManager.setCamMode(1);
							builder.bindEvent();

					}else{
						builder.clearArea();
					}

					if(id !== 4)
						builder.load( (id === 2 ? document.getElementById('levelData').value : "") );

					builder.renderArea();
					renderManager.renderFrame();

				break;
				case GUI.MAIN :
					if(id === 2){
						builder.clearArea();
						builder.clearEvent();
						renderManager.renderFrame();

					}else{
						renderManager.stopUpdate();
						renderManager.clearGrid();
						renderManager.clearGround();
					}

				break;
				case GUI.GUIPLAYER:
					snake.paused = false;
				break;
				case GUI.INGAME:
					snake.paused = true;
				break;
				case GUI.CRAFTMENU:
					document.getElementById('levelData').value = builder.export();
				break;
			}

			this.activeNode.style.display = 'none';
			this.list[guiId].style.display = '';
			this.active = guiId;
			this.activeNode = this.list[guiId];
		},

		selectLevel : function(e){
			if(e.target.localName !== 'span' || e.target.className.indexOf('active') === -1)
				return;

			var index = e.target.firstChild.data;
			this.currentLevel = index;
			map.updateData(LEVELS[index]);

			this.setActive(GUI.GUIPLAYER);
		},

		startNextLevel : function(){
			var node = document.getElementById('levelList').childNodes[this.currentLevel];
			node.className +=' finished';
			node.title = snake.moveCount;

			var score = save[this.currentLevel*2] + (save[this.currentLevel*2+1]>>5);

			if(snake.moveCount < score || score === 0){
				save[this.currentLevel*2] = snake.moveCount &31;
				save[this.currentLevel*2+1] = snake.moveCount >>5;

				localStorage.setItem('save', arrayToString(save));
			}

			this.currentLevel++;

			if(LEVELS.length > this.currentLevel){
				map.updateData(LEVELS[this.currentLevel]);
				document.getElementById('levelList').childNodes[this.currentLevel].className='active';

			}else{
				console.log('end');
				this.currentLevel = 0;
				map.updateData(LEVELS[this.currentLevel]);
			}
		},

		quit : function(){
		},

		keyDown : function(e){
			switch(e.keyCode){
				case 90: case 87: case 38:
						if(!snake.paused)
							snake.setDir(0);
					break;

				case 83: case 40:
						if(!snake.paused)
							snake.setDir(2);
					break;

				case 81: case 65: case 37:
						if(!snake.paused)
							snake.setDir(1);
					break;

				case 68: case 39:
						if(!snake.paused)
							snake.setDir(3);
					break;

				case 80: case 27:
						switch(this.active){
							case GUI.GUIPLAYER:
									this.setActive(GUI.INGAME);
								break;
							case GUI.CRAFTBOX:
									this.setActive(GUI.CRAFTMENU);
								break;
							case GUI.INGAME:
									this.setActive(GUI.GUIPLAYER);
								break;
							case GUI.CRAFTMENU:
									this.setActive(GUI.CRAFTBOX,4);
								break;
						}
					break;
			}
		}
	};


//- MAIN
		var save = (function(){
			var result = stringToArray(localStorage.getItem('save')) || [];

			for(var i=result.length; i<LEVELS.length*2; i++)
				result.push(0);

			localStorage.setItem('save', arrayToString(result));
			return result;
		})();

		var snake = new Snake();
		var map = new Map();
		var renderManager = new RenderManager();
		var animationManager = new AnimationManager();
		var builder = new Builder();
		var actionManager = new ActionManager();

		window.addEventListener('load', function(){
			document.body.insertBefore(CANVAS, document.body.firstChild);
			renderManager.cam.rotation.order = 'YXZ';
			snake.nodeScore = document.getElementById('guiPlayer').firstChild;
		}, false);

		function stringToArray(string){
			if(!string)
				return undefined;

			var result = [];

			for(var i=0, code; i<string.length; i++){
				code = string.charCodeAt(i);
				if(code < 97)
					result.push(code-65);
				else
					result.push(code-71);
			}

			return result;
		}

		function arrayToString(array){
			if(!array)
				return undefined;

			var result = "";

			for(var i=0; i<array.length; i++)
				if(array[i]<26)
					result += String.fromCharCode(array[i]+65);
				else
					result += String.fromCharCode(array[i]+71);

			return result;
		}

		function checkInput(input, value){
			Ginput = input;
			if(value > input.max){
				input.value = input.max;
				return parseInt(input.max);
			}

			if(value < input.min || isNaN(value)){
				input.value = input.min;
				return parseInt(input.min);
			}

			return value;
		}
		var Ginput;
	</script>
</head>
<body>
	<div id='craftBox' style='display:none;'>
		<div id='craftColor'>
			<span class='BLACK select'></span>
			<span class='GREEN'></span>
			<span class='RED'></span>
			<span class='YELLOW'></span>
			<span class='BLUE'></span>
			<span class='CYAN'></span>
			<span class='VIOLET'></span>
			<span class='WHITE'></span>
		</div>
		<div id='craftGeo' class='menu'>
			<span></span>
		</div>
	</div>

	<div id='guiPlayer' style='display:none;'>0</div>

	<div id='inGame' class='menu' style='display:none;'>
		<button class='quit'>quitter</button>
		<button class='resume'>retour</button>
	</div>

	<div id='mainMenu' class='menu'>
		<button class='play'>jouer</button>
		<button class='build'>crer</button>
	</div>

	<div id='levelSelect' class='menu' style='display:none;'>
		<div id='levelList'></div>
		<button class='quit'>retour</button>
	</div>

	<div id='craftMenu' class='menu' style='display:none;'>
		<button class='quit'>quitter</button>
		<button class='clear'>clear</button>
		<button class='load'>load</button>
		<input id='levelData' type='text'>
		<p>H</p><input id='levelHeight' type='number' value='10' min='5' max='30'>
		<p>L</p><input id='levelWidth' type='number' value='10' min='5' max='30'>
		<p class='score'>Or</p><input id='gold' type='number' value='10' min='1' max='1000'><br/>
		<p class='score'>Argent</p><input id='silver' type='number' value='10' min='1' max='1000'><br/>
		<p class='score'>Cuivre</p><input id='copper' type='number' value='10' min='1' max='1000'>
	</div>
</body>
</html>