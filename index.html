<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>SnakeColor</title>
	<style>
		body{
			margin:0px;
		}

	</style>
	<script type="text/javascript" charset="UTF-8" src="three.min.js"></script>
	<script>

//----- STATIC
		var V3 = THREE.Vector3;
		var F3 = THREE.Face3;
		var CANVAS;
		var COLOR = {
			BLACK: 0,
			GREEN: 1,
			RED: 2,
			YELLOW: 3,
			BLUE: 4,
			CYAN: 5,
			VIOLET: 6,
			WHITE: 7,

			RGB:[
				new V3(0,0,0),
				new V3(1/255*40, 1/255*180, 1/255*20),
				new V3(1,0,0),
				new V3(1,1,0),
				new V3(0,0,1),
				new V3(0,1,1),
				new V3(1,0,1),
				new V3(1,1,1)
			]
		};

		var GEO = {
			snakePart: (function(){
				var geo = new THREE.Geometry();
				geo.vertices = convertArray([
					-.4, .2, -.4,
					-.4, .2,  .4, 
					 .4, .2,  .4,
					 .4, .2, -.4,

					-.4, .0, -.4,
					-.4, .0,  .4,
					 .4, .0,  .4,
					 .4, .0, -.4
				], THREE.Vector3);

				geo.faces = convertArray([
					0,1,2, 0,2,3,
					0,4,5, 0,5,1,
					1,5,6, 1,6,2,
					2,6,7, 2,7,3,
					3,7,4, 3,4,0,
					5,4,7, 5,7,6 
				], THREE.Face3);
				return geo;
			})(),

			dot: (function(){
				var geo = new THREE.Geometry();
				geo.vertices = convertArray([
					-.1, .1, -.1,
					-.1, .1,  .1, 
					 .1, .1,  .1,
					 .1, .1, -.1,

					-.1, .0, -.1,
					-.1, .0,  .1,
					 .1, .0,  .1,
					 .1, .0, -.1
				], THREE.Vector3);

				geo.faces = convertArray([
					0,1,2, 0,2,3,
					0,4,5, 0,5,1,
					1,5,6, 1,6,2,
					2,6,7, 2,7,3,
					3,7,4, 3,4,0,
					5,4,7, 5,7,6 
				], THREE.Face3);
				return geo;
			})(),

			colorSwaper: (function(){
				var geo = new THREE.Geometry();
				geo.vertices = convertArray([
					-.2, .05, -.2,
					-.2, .05,  .2, 
					 .2, .05,  .2,
					 .2, .05, -.2,

					-.4,  0, -.4,
					-.4,  0,  .4,
					 .4,  0,  .4,
					 .4,  0, -.4,

					-.45, -.049, -.45,
					-.45, -.049,  .45,
					 .45, -.049,  .45,
					 .45, -.049, -.45
				], THREE.Vector3);

				geo.faces = convertArray([
					0,4,5, 0,5,1,
					1,5,6, 1,6,2,
					2,6,7, 2,7,3,
					3,7,4, 3,4,0,

					0,5,4, 0,1,5,
					1,6,5, 1,2,6,
					2,7,6, 2,3,7,
					3,4,7, 3,0,4,

					4,8,9,   4,9,5,
					5,9,10,  5,10,6,
					6,10,11, 6,11,7,
					7,11,8,  7,8,4

				], THREE.Face3);

				return geo;
			})(),

			ground: (function(){
				var geo = new THREE.Geometry();
				geo.vertices = convertArray([
					-.4,  0, -.4,
					-.4,  0,  .4,
					 .4,  0,  .4,
					 .4,  0, -.4,

					-.5, -.1, -.5,  
					-.5, -.1,  .5, 
					 .5, -.1,  .5, 
					 .5, -.1, -.5
				], THREE.Vector3);

				geo.faces = convertArray([
					0,1,2, 0,2,3,
					0,4,5, 0,5,1,
					1,5,6, 1,6,2,
					2,6,7, 2,7,3,
					3,7,4, 3,4,0
				], THREE.Face3);

				return geo;
			})(),

			wall: (function(){
				var geo = new THREE.Geometry();
				geo.vertices = convertArray([
					-.4,  .4, -.4,
					-.4,  .4,  .4,
					 .4,  .4,  .4,
					 .4,  .4, -.4,

					-.5,  .3, -.5,
					-.5,  .3,  .5,
					 .5,  .3,  .5,
					 .5,  .3, -.5,

					-.5, -.1, -.5,
					-.5, -.1,  .5,
					 .5, -.1,  .5,
					 .5, -.1, -.5
				], THREE.Vector3);

				geo.faces = convertArray([
					0,1,2, 0,2,3,
					0,4,5, 0,5,1,
					1,5,6, 1,6,2,
					2,6,7, 2,7,3,
					3,7,4, 3,4,0,

					4,8,9,   4,9,5,
					5,9,10,  5,10,6,
					6,10,11, 6,11,7,
					7,11,8,  7,8,4
				], THREE.Face3);

				return geo;
			})()
		};

		var MAT = {
			color : function(color){
				var vert = [
					"#ifdef GL_ES",
					"precision mediump float;",
					"#endif",

					"void main(){",
						"gl_Position = projectionMatrix *modelViewMatrix *vec4(position, 1.0);",
					"}"
				].join('\n');
				var frag = [
					"#ifdef GL_ES",
					"precision mediump float;",
					"#endif",

					"uniform vec3 color;",

					"void main(void){",
						"gl_FragColor = vec4(color, 1.);",
					"}"
				].join('\n');
				var attributes = [];

				return new THREE.ShaderMaterial({
			        uniforms: {color : {type: 'v3', value: color} },
			        attributes: {},
			        vertexShader:   vert,
			        fragmentShader: frag
			    });
			},
			alphaGradient : function(list, color){
				var vert = [
					"#ifdef GL_ES",
					"precision mediump float;",
					"#endif",

		    		"varying float vAlpha;",
		    		"attribute float alpha;",

					"void main(){",
						"vAlpha = alpha;",
						"gl_Position = projectionMatrix *modelViewMatrix *vec4(position, 1.0);",
					"}"
				].join('\n');
				var frag = [
					"#ifdef GL_ES",
					"precision mediump float;",
					"#endif",

					"uniform vec3 color;",
		    		"varying float vAlpha;",

					"void main(void){",
						"gl_FragColor = vec4(color, vAlpha);",
					"}"
				].join('\n');
				var attributes = [];

				return new THREE.ShaderMaterial({
			        uniforms: {color : {type: 'v3', value: color} },
			        attributes: {alpha : {type: 'f', value: list} },
			        vertexShader:   vert,
			        fragmentShader: frag,
			        transparent: true
			    });
			},
			grayGradient : function(list){
				var vert = [
					"#ifdef GL_ES",
					"precision mediump float;",
					"#endif",

		    		"varying float vGrad;",
		    		"attribute float grad;",

					"void main(){",
						"vGrad = grad;",
						"gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0 );",
					"}"
				].join('\n');
				var frag = [
					"#ifdef GL_ES",
					"precision mediump float;",
					"#endif",

		    		"varying float vGrad;",

					"void main(void){",
						"gl_FragColor = vec4(vGrad, vGrad, vGrad,1.);",
					"}"
				].join('\n');
				var attributes = [];

				return new THREE.ShaderMaterial({
			        uniforms:       {},
			        attributes:     {
			        	grad : {type: 'f', value: list}
			        },
			        vertexShader:   vert,
			        fragmentShader: frag
			    });
			}
		};


//----- SNAKE
		function Snake(){
			this.pos = {x: 0, y: 0};
			this.maxLength = 5;
			this.speed = 500;
			this.nextMove = 0;

			this.dir = -1;
			this.parts = [];
			this.color = COLOR.GREEN;
		}

		Snake.prototype = {
			growUp : function(){
				this.maxLength++;
			},

			setDir : function(newDir){
				var lastPart = this.parts[this.parts.length-2];
				if(lastPart === undefined){
					this.dir = newDir;
					return;
				}

				switch(newDir){
					case 0: 
							if(this.pos.x !== lastPart.x || this.pos.y !== lastPart.y+1){
								console.log(this.pos.x+','+this.pos.y+' | '+lastPart.x+','+lastPart.y);
								this.dir = newDir;
							}
						break;
					case 1:
							if(this.pos.y !== lastPart.y || this.pos.x !== lastPart.x+1){
								console.log(this.pos.x+','+this.pos.y+' | '+lastPart.x+','+lastPart.y);
								this.dir = newDir;
							}
						break;
					case 2:
							if(this.pos.x !== lastPart.x || this.pos.y !== lastPart.y-1){
								console.log(this.pos.x+','+this.pos.y+' | '+lastPart.x+','+lastPart.y);
								this.dir = newDir;
							}
						break;
					case 3:
							if(this.pos.y !== lastPart.y || this.pos.x !== lastPart.x-1){
								console.log(this.pos.x+','+this.pos.y+' | '+lastPart.x+','+lastPart.y);
								this.dir = newDir;
							}
						break;
				}
			},

			update : function(delta){
				this.nextMove-=delta;
				if(this.nextMove>0)
					return;

				this.nextMove+=this.speed;

				switch(this.dir){
					case 0: this.pos.y--;
						break;
					case 1: this.pos.x--;
						break;
					case 2: this.pos.y++;
						break;
					case 3: this.pos.x++;
						break;
					default: return;
				}

				//if(map.moveIn(this)){
					var lastPart = this.parts[this.parts.length-1];

					var mesh = renderManager.craftMesh(TYPE.LIST[TYPE.SNAKE], this.pos.x, this.pos.y);
					var vx = this.pos.x + (this.dir === 1 ? .6 : this.dir === 3 ? -.6 : 0);
					var vz = this.pos.y + (this.dir === 0 ? .6 : this.dir === 2 ? -.6 : 0);

					animationManager.pushAnimation(mesh, {
						'position' : {from: new V3(vx,0,vz), to: mesh.position.clone()},
						'scale' : {from: new V3(.1,.1,.1), to: new V3(1,1,1)}
					}, this.speed, 0);

					this.parts.push({x: this.pos.x, y: this.pos.y});

					if(this.parts.length > this.maxLength){
						renderManager.clearMesh( this.parts[0].x, this.parts[1].y);
						this.parts = this.parts.splice(1);
					}
				//}
			},

			reset : function(){
				this.maxLength = 5;
				this.parts = [map.spawn];
				this.dir = -1;
				renderManager.craftMesh(TYPE.LIST[TYPE.SNAKE], this.pos.x, this.pos.y);

				this.color = COLOR.GREEN;
				this.pos.x = map.spawn.x;
				this.pos.y = map.spawn.y;
			}
		};


//----- MAP
		function Map(){
			this.currentData = null;
			this.grid = [];
			this.ld = {};

			this.height = 0;
			this.width = 0;

			this.spawn = {x: 0, y: 0};
		}

		Map.prototype = {
			updateData : function(ld){//ld=> LevelData TODO basic
				this.ld = ld;

				this.height = ld.height;
				this.width = ld.width;
				this.spawn = ld.spawn;

				renderManager.initGrid(this.height+2, this.width+2);

				this.grid = [];
				for(var i=-1, endI=this.width+1, endJ=this.height+1, length, gridS,entityS;  i<endI;  i++){
					this.grid.push([]);

					length = this.grid.length-1;

					for(var j=-1; j<endJ; j++){
						if(i<0 || j<0 || i>=this.width || j>=this.height)
							gridS = TYPE.LIST[ TYPE.WALL ];
						else
							gridS = TYPE.LIST[ ld.grid[i +j*ld.width] ];
						
						this.grid[length].push(gridS);
						renderManager.craftMesh(gridS, i+1, j+1);
					}
				}

				snake.reset();
			},

			clearEntity : function(pos){
				var entity = this.entities[pos.x][pos.y];

				if(entity.type !== undefined){
					renderManager.clearMesh(entity);
					this.entities[pos.x][pos.y] = {};
				}
			},

			reset : function(){
				snake.reset();

				for(var i=0,j,select; i<this.grid.length; i++){
					this.grid.push([]);

					for(j=0; j<this.height; j++){
						var select = this.ld.grid[i *this.height +j];

						if(select !== undefined){
							var mesh = renderManager.defineMesh(select);
							this.entities[i].push({type: select, mesh: mesh});

						}else
							this.entities[i].push({});
					}
				}
			}
		};


//----- KEYBINDER
		function KeyBinder(){
			this.paused = false;

			var self = this;
			window.addEventListener('keydown', function(e){console.log(e.keyCode);
				switch(e.keyCode){
					case 90: case 87: case 38:
							snake.setDir(0);
						break;

					case 83: case 40:
							snake.setDir(2);
						break;

					case 81: case 65: case 37:
							snake.setDir(1);
						break;

					case 68: case 39:
							snake.setDir(3);
						break;

					case 80:
							//TODO pause
						break;
				}
			}, false);
		}

		KeyBinder.prototype = {
			bind : function(type, call){


			}
		};


//----- ANIMATION
		function AnimationManager(){
			this.list = [];
		}

		AnimationManager.prototype = {
			pushAnimation : function(mesh, param, duration, delay){
				this.list.push(new Animation(mesh, param, duration, delay));
			},


			update : function(delta){
				for(var i=0; i<this.list.length; i++)
					if(this.list[i].update(delta)){
						this.list.splice(i,1);
						i--;
					}
			}
		};


		function Animation(mesh, param, duration, delay){
			this.mesh = mesh;
			this.param = param;
			this.duration = duration;
			this.delay = delay || 0;

			if(this.delay === 0)
				for(key in this.param)
					this.mesh[key].set(
						this.param[key].from.x,
						this.param[key].from.y,
						this.param[key].from.z
					);
		}

		Animation.prototype = {
			update : function(delta){
				this.delay -= delta;

				if(this.delay>0)
					return;

				var off = -this.delay/ this.duration;

				if(off>1)
					off = 1;

				var offN = 1-off;

				for(key in this.param)
					this.mesh[key].set(
						this.param[key].from.x *offN + this.param[key].to.x *off,
						this.param[key].from.y *offN + this.param[key].to.y *off,
						this.param[key].from.z *offN + this.param[key].to.z *off
					);

				return off === 1;
			}
		};


		function convertArray(list, type){
			var r = [];//result
			for(var i=0; i<list.length; i+=3)
				r.push(new type(list[i], list[i+1], list[i+2]));

			return r;
		}


//----- ENTITIES CONSTRUCTOR + STATIC
		function SnakePart(){
			this.color;
			this.mesh = this.craftMesh();
		}

		SnakePart.prototype = {
			moveIn : function(){
				return false;
			},

			craftMesh : function(){
				var mat = MAT.color(COLOR.RGB[ COLOR.GREEN ]);
				this.color = mat.uniforms.color;
				return new THREE.Mesh(GEO.snakePart, mat);
			}
		};


		function ColorSwaper(color, pos){
			this.color = color;
			this.mesh = this.craftMesh();
		}

		ColorSwaper.prototype =	{
			moveIn : function(snake){
				if(snake.color !== this.color){
					snake.color = this.color;
				}
				return true;
			},

			craftMesh : function(){
				return new THREE.Mesh(GEO.colorSwaper, MAT.alphaGradient([.4,.4,.4,.4, .25,.25,.25,.25], this.color));
			}
		};

		function Block(height){
			this.height = height;
			this.mesh = this.craftMesh();
			this.ground = true;
		}

		Block.prototype = {
			moveIn : function(snake){
				return this.height === 0;
			},

			craftMesh : function(){
				if(this.height === 0)
					return new THREE.Mesh(GEO.ground, MAT.grayGradient([.4,.4,.4,.4, .25,.25,.25,.25]));
				else
					return new THREE.Mesh(GEO.wall, MAT.grayGradient([.4,.4,.4,.4, .25,.25,.25,.25, .25,.25,.25,.25]));
			}
		};

		function Dot(color){
			this.color = color;
			this.mesh = this.craftMesh();
		}

		Dot.prototype = {
			moveIn : function(snake){
				if(snake.color === this.color){
					snake.maxLength++;

					return true;
				}	
				else
					return false;
			},

			craftMesh : function(){
				return new THREE.Mesh(GEO.dot, MAT.color(this.color));
			}
		};

		var TYPE = {
			GROUND: 0,
			WALL: 1,
			SNAKE: 2,

			SWAPERBLACK: 3,
			SWAPERGREEN: 4,
			SWAPERRED: 5,
			SWAPERYELLOW: 6,

			LIST: [
				new Block(0),
				new Block(1),
				new SnakePart(),

				new ColorSwaper(COLOR.RGB[ COLOR.BLACK ]),
				new ColorSwaper(COLOR.RGB[ COLOR.GREEN ]),
				new ColorSwaper(COLOR.RGB[ COLOR.RED ]),
				new ColorSwaper(COLOR.RGB[ COLOR.YELLOW ]),
				new ColorSwaper(COLOR.RGB[ COLOR.BLUE ]),
				new ColorSwaper(COLOR.RGB[ COLOR.CYAN ]),
				new ColorSwaper(COLOR.RGB[ COLOR.VIOLET ]),
				new ColorSwaper(COLOR.RGB[ COLOR.WHITE ]),

				new Dot(COLOR.RGB[ COLOR.BLACK ]),
				new Dot(COLOR.RGB[ COLOR.GREEN ]),
				new Dot(COLOR.RGB[ COLOR.RED ]),
				new Dot(COLOR.RGB[ COLOR.YELLOW ]),
				new Dot(COLOR.RGB[ COLOR.BLUE ]),
				new Dot(COLOR.RGB[ COLOR.CYAN ]),
				new Dot(COLOR.RGB[ COLOR.VIOLET ]),
				new Dot(COLOR.RGB[ COLOR.WHITE ])
			]
		};
		TYPE.LIST['undefined'] = TYPE.LIST[0];
//----- RENDERMANAGER
		function RenderManager(){
			this.cam = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 1, 100);
			this.renderer = new THREE.WebGLRenderer({antialias: false});
   			this.scene = new THREE.Scene();
   			
   			this.grid;

			CANVAS = this.renderer.domElement;
   			this.onRun = false;
   			this.lastTick = 0;

			var self = this;
			window.onresize = function(){self.updateSize();};
   			this.updateSize();
		}

		RenderManager.prototype = {
			startUpdate : function(){
				this.onRun = true;
				this.lastTick = Date.now();
				this.update(this);
			},

			stopUpdate : function(){
				this.onRun = false;
			},

			update : function(rm){//rm => RenderManager
				var delta = Date.now() -rm.lastTick;
				rm.lastTick += delta;

				if(rm.onRun)
					requestAnimationFrame(function(){rm.update(rm);});

				rm.renderer.render(rm.scene, rm.cam);
				snake.update(delta);
				animationManager.update(delta);
			},

			updateSize : function(e){
				this.cam.aspect = window.innerWidth /window.innerHeight;
				this.cam.updateProjectionMatrix();

				this.renderer.setSize( window.innerWidth, window.innerHeight);
				CANVAS.style.height = window.innerHeight-5 +'px';
				CANVAS.style.width = window.innerWidth +'px';
			},

			initGrid : function(height, width){
				this.grid = [];
				this.ground = [];

				for(var i=0, j; i<width; i++){
					this.grid.push([]);
					this.ground.push([]);

					for(j=0; j<height; j++){
						this.grid[i].push();
						this.ground[i].push();
					}
				}
			},

			craftMesh : function(type, x, y){
				if(type === undefined)
					return;

				var mesh = type.mesh.clone();
				mesh.position.x = x;
				mesh.position.z = y;

				this.grid[x][y] = mesh;

				this.scene.add(mesh);

				if(type.ground === undefined){
					var ground = TYPE.LIST['undefined'].mesh.clone();

					ground.position.x = x;
					ground.position.z = y;

					this.scene.add(ground);
				}

				return mesh;
			},

			clearMesh : function(x, y){
				this.scene.remove(this.grid[x][y]);
				this.grid[x][y] = undefined;
			}
		};

//----- MAIN
		var snake = new Snake();
		var map = new Map();
		var keyBinder = new KeyBinder();
		var renderManager = new RenderManager();
		var animationManager = new AnimationManager();

		window.addEventListener('load', function(){
			document.body.appendChild(CANVAS);

			map.updateData({
				height: 10,
				width: 10,
				spawn: {x:5, y:5},
				grid: [
					0,1,2,3,4, 10,11,12,13,14,
					0,0,0,0,0, 0,0,0,0,0,
					0,0,1,1,1, 0,0,0,0,0,
					0,0,0,1,1, 0,0,0,0,0,
					0,0,1,0,1, 0,0,0,1,0,

					0,1,0,0,0, 1,0,1,0,0,
					0,0,0,0,0, 1,1,0,0,0,
					0,0,0,0,0, 1,1,1,0,0,
					0,0,0,0,0, 0,0,0,0,0,
					0,0,0,0,0, 0,0,0,0,0
				]});

			renderManager.cam.position.y = 3;
			renderManager.cam.position.x = 5;
			renderManager.cam.position.z = 10;
			renderManager.cam.rotation.x = -Math.PI/5;

			renderManager.startUpdate();
		}, false);

		window.addEventListener('keypress', function(e){

			/*switch(e.keyCode){
				case 101: renderManager.cam.position.z--;
					break;
				case 100: renderManager.cam.position.z++;
					break;
				case 115: renderManager.cam.position.x--;
					break;
				case 102: renderManager.cam.position.x++;
					break;
				case 122: renderManager.cam.position.y--;
					break;
				case 114: renderManager.cam.position.y++;
					break;
			}*/
		}, false);
	</script>
</head>
<body>
</body>
</html>