<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>SnakeColor</title>
	<style>
		body{
			margin:0px;
		}

	</style>
	<script type="text/javascript" charset="UTF-8" src="three.min.js"></script>
	<script>

//----- STATIC
		var V3 = THREE.Vector3;
		var F3 = THREE.Face3;
		var CANVAS;
		var COLOR = {
			BLACK: 0,
			GREEN: 1,
			RED: 2,
			YELLOW: 3,
			BLUE: 4,
			CYAN: 5,
			VIOLET: 6,
			WHITE: 7,

			RGB:[
				new V3(0,0,0),
				new V3(1/255*40, 1/255*180, 1/255*20),
				new V3(1,0,0),
				new V3(1,1,0),
				new V3(0,0,1),
				new V3(0,1,1),
				new V3(1,0,1),
				new V3(1,1,1)
			]
		};

		var GEO = {
			snakePart: (function(){
				var geo = new THREE.Geometry();
				geo.vertices = convertArray([
					-.4, .2, -.4,
					-.4, .2,  .4, 
					 .4, .2,  .4,
					 .4, .2, -.4,

					-.4, .0, -.4,
					-.4, .0,  .4,
					 .4, .0,  .4,
					 .4, .0, -.4
				], THREE.Vector3);

				geo.faces = convertArray([
					0,1,2, 0,2,3,
					0,4,5, 0,5,1,
					1,5,6, 1,6,2,
					2,6,7, 2,7,3,
					3,7,4, 3,4,0,
					5,4,7, 5,7,6 
				], THREE.Face3);
				return geo;
			})(),

			dot: (function(){
				var geo = new THREE.Geometry();
				geo.vertices = convertArray([
					-.1, .1, -.1,
					-.1, .1,  .1, 
					 .1, .1,  .1,
					 .1, .1, -.1,

					-.1, .0, -.1,
					-.1, .0,  .1,
					 .1, .0,  .1,
					 .1, .0, -.1
				], THREE.Vector3);

				geo.faces = convertArray([
					0,1,2, 0,2,3,
					0,4,5, 0,5,1,
					1,5,6, 1,6,2,
					2,6,7, 2,7,3,
					3,7,4, 3,4,0,
					5,4,7, 5,7,6 
				], THREE.Face3);
				return geo;
			})(),

			colorSwaper: (function(){
				var geo = new THREE.Geometry();
				geo.vertices = convertArray([
					-.2, .05, -.2,
					-.2, .05,  .2, 
					 .2, .05,  .2,
					 .2, .05, -.2,

					-.4,  0, -.4,
					-.4,  0,  .4,
					 .4,  0,  .4,
					 .4,  0, -.4,

					-.45, -.049, -.45,
					-.45, -.049,  .45,
					 .45, -.049,  .45,
					 .45, -.049, -.45
				], THREE.Vector3);

				geo.faces = convertArray([
					0,4,5, 0,5,1,
					1,5,6, 1,6,2,
					2,6,7, 2,7,3,
					3,7,4, 3,4,0,

					0,5,4, 0,1,5,
					1,6,5, 1,2,6,
					2,7,6, 2,3,7,
					3,4,7, 3,0,4,

					4,8,9,   4,9,5,
					5,9,10,  5,10,6,
					6,10,11, 6,11,7,
					7,11,8,  7,8,4

				], THREE.Face3);

				return geo;
			})(),

			ground: (function(){
				var geo = new THREE.Geometry();
				geo.vertices = convertArray([
					-.4,  0, -.4,
					-.4,  0,  .4,
					 .4,  0,  .4,
					 .4,  0, -.4,

					-.5, -.1, -.5,  
					-.5, -.1,  .5, 
					 .5, -.1,  .5, 
					 .5, -.1, -.5
				], THREE.Vector3);

				geo.faces = convertArray([
					0,1,2, 0,2,3,
					0,4,5, 0,5,1,
					1,5,6, 1,6,2,
					2,6,7, 2,7,3,
					3,7,4, 3,4,0
				], THREE.Face3);

				return geo;
			})(),

			wall: (function(){
				var geo = new THREE.Geometry();
				geo.vertices = convertArray([
					-.4,  .4, -.4,
					-.4,  .4,  .4,
					 .4,  .4,  .4,
					 .4,  .4, -.4,

					-.5,  .3, -.5,
					-.5,  .3,  .5,
					 .5,  .3,  .5,
					 .5,  .3, -.5,

					-.5, -.1, -.5,
					-.5, -.1,  .5,
					 .5, -.1,  .5,
					 .5, -.1, -.5
				], THREE.Vector3);

				geo.faces = convertArray([
					0,1,2, 0,2,3,
					0,4,5, 0,5,1,
					1,5,6, 1,6,2,
					2,6,7, 2,7,3,
					3,7,4, 3,4,0,

					4,8,9,   4,9,5,
					5,9,10,  5,10,6,
					6,10,11, 6,11,7,
					7,11,8,  7,8,4
				], THREE.Face3);

				return geo;
			})()
		};

		var MAT = {
			color : function(color){
				var vert = [
					"#ifdef GL_ES",
					"precision mediump float;",
					"#endif",

					"void main(){",
						"gl_Position = projectionMatrix *modelViewMatrix *vec4(position, 1.0);",
					"}"
				].join('\n');
				var frag = [
					"#ifdef GL_ES",
					"precision mediump float;",
					"#endif",

					"uniform vec3 color;",

					"void main(void){",
						"gl_FragColor = vec4(color, 1.);",
					"}"
				].join('\n');
				var attributes = [];

				return new THREE.ShaderMaterial({
			        uniforms: {color : {type: 'v3', value: color} },
			        attributes: {},
			        vertexShader:   vert,
			        fragmentShader: frag
			    });
			},
			alphaGradient : function(list, color){
				var vert = [
					"#ifdef GL_ES",
					"precision mediump float;",
					"#endif",

		    		"varying float vAlpha;",
		    		"attribute float alpha;",

					"void main(){",
						"vAlpha = alpha;",
						"gl_Position = projectionMatrix *modelViewMatrix *vec4(position, 1.0);",
					"}"
				].join('\n');
				var frag = [
					"#ifdef GL_ES",
					"precision mediump float;",
					"#endif",

					"uniform vec3 color;",
		    		"varying float vAlpha;",

					"void main(void){",
						"gl_FragColor = vec4(color, vAlpha);",
					"}"
				].join('\n');
				var attributes = [];

				return new THREE.ShaderMaterial({
			        uniforms: {color : {type: 'v3', value: color} },
			        attributes: {alpha : {type: 'f', value: list} },
			        vertexShader:   vert,
			        fragmentShader: frag,
			        transparent: true
			    });
			},
			grayGradient : function(list){
				var vert = [
					"#ifdef GL_ES",
					"precision mediump float;",
					"#endif",

		    		"varying float vGrad;",
		    		"attribute float grad;",

					"void main(){",
						"vGrad = grad;",
						"gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0 );",
					"}"
				].join('\n');
				var frag = [
					"#ifdef GL_ES",
					"precision mediump float;",
					"#endif",

		    		"varying float vGrad;",

					"void main(void){",
						"gl_FragColor = vec4(vGrad, vGrad, vGrad,1.);",
					"}"
				].join('\n');
				var attributes = [];

				return new THREE.ShaderMaterial({
			        uniforms:       {},
			        attributes:     {
			        	grad : {type: 'f', value: list}
			        },
			        vertexShader:   vert,
			        fragmentShader: frag
			    });
			}
		};

		function convertArray(list, type, length){
			var r = [];//result

				for(var i=0; i<list.length; i+=3)
					r.push(new type(list[i], list[i+1], list[i+2]));

			return r;
		}

//----- SNAKE
		function Snake(){
			this.pos = {x: 0, y: 0};
			this.maxLength = 5;
			this.speed = 150;
			this.nextMove = 0;

			this.dir = -1;
			this.parts = [];
			this.color = COLOR.GREEN;
		}

		Snake.prototype = {
			growUp : function(){
				this.maxLength++;
			},

			setDir : function(newDir){
				var lastPart = this.parts[this.parts.length-2];
				if(lastPart === undefined){
					this.dir = newDir;
					return;
				}

				switch(newDir){
					case 0:
							if(this.pos.x !== lastPart.x || this.pos.y !== lastPart.y+1)
								this.dir = newDir;
						break;
					case 1:
							if(this.pos.y !== lastPart.y || this.pos.x !== lastPart.x+1)
								this.dir = newDir;
						break;
					case 2:
							if(this.pos.x !== lastPart.x || this.pos.y !== lastPart.y-1)
								this.dir = newDir;
						break;
					case 3:
							if(this.pos.y !== lastPart.y || this.pos.x !== lastPart.x-1)
								this.dir = newDir;
						break;
				}
			},

			update : function(delta){
				this.nextMove-=delta;
				if(this.nextMove>0)
					return;

				this.nextMove+=this.speed;

				switch(this.dir){
					case 0: this.pos.y--;
						break;
					case 1: this.pos.x--;
						break;
					case 2: this.pos.y++;
						break;
					case 3: this.pos.x++;
						break;
					default: return;
				}

				if(map.moveIn(this)){
					var lastPart = this.parts[this.parts.length-1];

					var mesh = renderManager.craftMesh(TYPE.LIST[TYPE.SNAKE], this.pos.x, this.pos.y);
					var vx = (this.dir === 1 ? 1 : this.dir === 3 ? -1 : 0);
					var vz = (this.dir === 0 ? 1 : this.dir === 2 ? -1 : 0);

					animationManager.pushAnimation(mesh, {
						'position': {from: new V3(this.pos.x +vx *.6, 0, this.pos.y +vz *.6), to: mesh.position.clone()},
						'scale': {from: new V3(.1,.1,.1), to: new V3(1,1,1)}
					}, this.speed, 0);

					var camP = renderManager.cam.position.clone();
					animationManager.pushAnimation(renderManager.cam, {
						'position': {from: camP, to: new V3(this.pos.x, camP.y, this.pos.y+.5)}
					}, this.speed, 0);

					this.parts.push({x: this.pos.x, y: this.pos.y});
					map.setPos(this.pos.x, this.pos.y, TYPE.LIST[TYPE.SNAKE]);

					if(this.parts.length > this.maxLength){
						var part = this.parts[0];
						var mesh = renderManager.grid[part.x][part.y];

						map.clearPos(part.x, part.y);
						this.parts = this.parts.splice(1);

						animationManager.pushAnimation(mesh, {
							'position': {from: new V3(part.x, 0, part.y), to: new V3(this.parts[0].x, 0, this.parts[0].y)},
							'scale': {from: new V3(1,1,1), to: new V3(.1,.1,.1)}
						}, this.speed, 0,
						function(mesh){renderManager.clearMesh(mesh);});
					}
				}else
					map.reset();
			},

			reset : function(){
				this.maxLength = 5;
				this.parts = [map.spawn];
				this.dir = -1;

				this.color = COLOR.GREEN;
				this.pos.x = map.spawn.x;
				this.pos.y = map.spawn.y;

				var mesh = renderManager.craftMesh(TYPE.LIST[TYPE.SNAKE], map.spawn.x, map.spawn.y);
				animationManager.pushAnimation(mesh, {
					'scale': {from: new V3(.05,.05,.05), to: new V3(1,1,1)}
				},400, 0);


				map.grid[map.spawn.x][map.spawn.y] = TYPE.LIST[TYPE.SNAKE];
				keyBinder.paused = false;
			}
		};


//----- MAP
		function Map(){
			this.currentData = null;
			this.grid = [];
			this.ld = {};

			this.height = 0;
			this.width = 0;
			this.spawn = {x: 0, y: 0};
		}

		Map.prototype = {
			updateData : function(ld){//ld=> LevelData TODO basic
				this.ld = ld;

				this.height = ld.height;
				this.width = ld.width;
				this.spawn = {x: ld.spawn.x+1, y: ld.spawn.y+1};

				renderManager.initGrid(this.height+2, this.width+2);

				this.grid = [];
				for(var i=-1, endI=this.width+1, endJ=this.height+1, length, select;  i<endI;  i++){
					this.grid.push([]);

					length = this.grid.length-1;

					for(var j=-1; j<endJ; j++){
						if(i<0 || j<0 || i>=this.width || j>=this.height)
							select = TYPE.LIST[ TYPE.WALL ];
						else
							select = TYPE.LIST[ ld.grid[i +j*ld.width] ];
						

						if(select !== undefined){
							if(select.ground === true)
								renderManager.addGround(select, i+1, j+1);

							else{
								renderManager.craftMesh(select, i+1, j+1);
								renderManager.addGround(TYPE.LIST[TYPE.GROUND], i+1, j+1);
							}

							this.grid[i+1].push(select);

						}else{
							this.grid[i+1].push(TYPE.LIST[TYPE.GROUND]);
							renderManager.addGround(TYPE.LIST[TYPE.GROUND], i+1, j+1);
						}

					}
				}

				snake.reset();
			},

			moveIn : function(snake){
				return this.grid[snake.pos.x][snake.pos.y].moveIn(snake);
			},

			clearPos : function(x, y){
				this.grid[x][y] = TYPE.LIST[TYPE.GROUND];
			},

			setPos : function(x, y, type){
				this.grid[x][y] = type;
			},

			reset : function(){
				keyBinder.paused = true;
				snake.dir = -1;

				for(var i= (snake.parts.length>25 ? snake.parts.length-25 : 0); i<snake.parts.length; i++){
					var mesh = renderManager.grid[snake.parts[i].x][snake.parts[i].y];

					animationManager.pushAnimation(mesh, {
						'rotation' : {from: new V3(0,0,0), to: new V3(0, Math.PI*4, 0)},
						'scale' : {from: new V3(1,1,1), to: new V3(0.05, 0.05, 0.05)}
					}, 400, i*50,
					function(mesh){renderManager.clearMesh(mesh);});
				}

				animationManager.pushAnimation(renderManager.cam, {
						'position': {from: renderManager.cam.position.clone(), to: new V3(map.spawn.x, renderManager.cam.position.y, map.spawn.y+.5)}
					}, 250, Math.min(25, snake.parts.length) *50+200,
					function(){
						for(var i=0, j; i<map.width; i++)
							for(var j=0; j<map.height; j++){
								select = TYPE.LIST[ map.ld.grid[i +j *map.width] ];

								if(select !== undefined)
									if(select.ground !== true){
										renderManager.craftMesh(select, i+1, j+1);
										map.grid[i+1][j+1] = select;

									}else{
										renderManager.clearPos(i+1, j+1);
										map.grid[i+1][j+1] = select;
									}
							}

						snake.reset();
					});
			}
		};


//----- KEYBINDER
		function KeyBinder(){
			this.paused = false;

			var self = this;
			window.addEventListener('keydown', function(e){
				if(self.paused)
					return;

				switch(e.keyCode){
					case 90: case 87: case 38:
							snake.setDir(0);
						break;

					case 83: case 40:
							snake.setDir(2);
						break;

					case 81: case 65: case 37:
							snake.setDir(1);
						break;

					case 68: case 39:
							snake.setDir(3);
						break;

					case 80:
							//TODO pause
						break;
				}
			}, false);
		}

		KeyBinder.prototype = {
			bind : function(type, call){


			}
		};


//----- ANIMATION
		function AnimationManager(){
			this.list = [];
		}

		AnimationManager.prototype = {
			pushAnimation : function(mesh, param, duration, delay, callback){
				this.list.push(new Animation(mesh, param, duration, delay, callback));
			},

			update : function(delta){
				for(var i=0; i<this.list.length; i++)
					if(this.list[i].update(delta)){
						this.list.splice(i,1);
						i--;
					}
			}
		};


		function Animation(mesh, param, duration, delay, callback){
			this.mesh = mesh;
			this.param = param;
			this.duration = duration;
			this.delay = delay || 0;
			this.callback = callback;

			if(this.delay === 0)
				for(key in this.param)
					this.mesh[key].set(
						this.param[key].from.x,
						this.param[key].from.y,
						this.param[key].from.z
					);
		}

		Animation.prototype = {
			update : function(delta){
				this.delay -= delta;

				if(this.delay>0)
					return;

				var off = -this.delay/ this.duration;

				if(off>1)
					off = 1;

				var offN = 1-off;

				for(key in this.param)
					this.mesh[key].set(
						this.param[key].from.x *offN + this.param[key].to.x *off,
						this.param[key].from.y *offN + this.param[key].to.y *off,
						this.param[key].from.z *offN + this.param[key].to.z *off
					);

				if(off === 1){
					if(this.callback)
						this.callback(this.mesh);
					return true;
				}

				return false;
			}
		};


//----- ENTITIES CONSTRUCTOR + STATIC
		function SnakePart(){
			this.color;
			this.mesh = this.craftMesh();
		}

		SnakePart.prototype = {
			moveIn : function(){
				return false;
			},

			craftMesh : function(){
				var mat = MAT.color(COLOR.RGB[ COLOR.GREEN ]);
				this.color = mat.uniforms.color;
				return new THREE.Mesh(GEO.snakePart, mat);
			}
		};


		function ColorSwaper(color, pos){
			this.color = color;
			this.mesh = this.craftMesh();
		}

		ColorSwaper.prototype =	{
			moveIn : function(snake){
				if(snake.color !== this.color){
					snake.color = this.color;
				}
				return true;
			},

			craftMesh : function(){
				return new THREE.Mesh(GEO.colorSwaper, MAT.alphaGradient([.4,.4,.4,.4, .25,.25,.25,.25], this.color));
			}
		};

		function Block(height){
			this.height = height;
			this.mesh = this.craftMesh();
			this.ground = true;
		}

		Block.prototype = {
			moveIn : function(snake){
				return this.height === 0;
			},

			craftMesh : function(){
				if(this.height === 0)
					return new THREE.Mesh(GEO.ground, MAT.grayGradient([.4,.4,.4,.4, .25,.25,.25,.25]));
				else
					return new THREE.Mesh(GEO.wall, MAT.grayGradient([.4,.4,.4,.4, .25,.25,.25,.25, .25,.25,.25,.25]));
			}
		};

		function Dot(color){
			this.color = color;
			this.mesh = this.craftMesh();
		}

		Dot.prototype = {
			moveIn : function(snake){
				if(snake.color === this.color){
					snake.maxLength++;

					return true;
				}	
				else
					return false;
			},

			craftMesh : function(){
				return new THREE.Mesh(GEO.dot, MAT.color(this.color));
			}
		};

		var TYPE = {
			GROUND: 0,
			WALL: 1,
			SNAKE: 2,

			SWAPERBLACK: 3,
			SWAPERGREEN: 4,
			SWAPERRED: 5,
			SWAPERYELLOW: 6,

			LIST: [
				new Block(0),
				new Block(1),
				new SnakePart(),

				new ColorSwaper(COLOR.RGB[ COLOR.BLACK ]),
				new ColorSwaper(COLOR.RGB[ COLOR.GREEN ]),
				new ColorSwaper(COLOR.RGB[ COLOR.RED ]),
				new ColorSwaper(COLOR.RGB[ COLOR.YELLOW ]),
				new ColorSwaper(COLOR.RGB[ COLOR.BLUE ]),
				new ColorSwaper(COLOR.RGB[ COLOR.CYAN ]),
				new ColorSwaper(COLOR.RGB[ COLOR.VIOLET ]),
				new ColorSwaper(COLOR.RGB[ COLOR.WHITE ]),

				new Dot(COLOR.RGB[ COLOR.BLACK ]),
				new Dot(COLOR.RGB[ COLOR.GREEN ]),
				new Dot(COLOR.RGB[ COLOR.RED ]),
				new Dot(COLOR.RGB[ COLOR.YELLOW ]),
				new Dot(COLOR.RGB[ COLOR.BLUE ]),
				new Dot(COLOR.RGB[ COLOR.CYAN ]),
				new Dot(COLOR.RGB[ COLOR.VIOLET ]),
				new Dot(COLOR.RGB[ COLOR.WHITE ])
			]
		};
		TYPE.LIST['undefined'] = TYPE.LIST[0];
//----- RENDERMANAGER
		function RenderManager(){
			this.cam = new THREE.PerspectiveCamera(125, window.innerWidth/window.innerHeight, 1, 100);
			this.renderer = new THREE.WebGLRenderer({antialias: false});
   			this.scene = new THREE.Scene();
   			
   			this.grid;

			CANVAS = this.renderer.domElement;
   			this.onRun = false;
   			this.lastTick = 0;

			var self = this;
			window.onresize = function(){self.updateSize();};
   			this.updateSize();
		}

		RenderManager.prototype = {
			startUpdate : function(){
				this.onRun = true;
				this.lastTick = Date.now();
				this.update(this);
			},

			stopUpdate : function(){
				this.onRun = false;
			},

			update : function(rm){//rm => RenderManager
				var delta = Date.now() -rm.lastTick;
				if(delta > 40)
					delta = 40;

				rm.lastTick += delta;

				if(rm.onRun)
					requestAnimationFrame(function(){rm.update(rm);});

				rm.renderer.render(rm.scene, rm.cam);
				snake.update(delta);
				animationManager.update(delta);
			},

			updateSize : function(e){
				this.cam.aspect = window.innerWidth /window.innerHeight;
				this.cam.updateProjectionMatrix();

				this.renderer.setSize( window.innerWidth, window.innerHeight);
				CANVAS.style.height = window.innerHeight-5 +'px';
				CANVAS.style.width = window.innerWidth +'px';
			},

			initGrid : function(height, width){
				this.grid = [];
				this.ground = [];

				for(var i=0, j; i<width; i++){
					this.grid.push([]);
					this.ground.push([]);

					for(j=0; j<height; j++){
						this.grid[i].push();
						this.ground[i].push();
					}
				}
			},

			craftMesh : function(type, x, y){
				if(type === undefined)
					return;

				var mesh = type.mesh.clone();
				mesh.position.x = x;
				mesh.position.z = y;

				if(this.grid[x][y] !== undefined)
					this.scene.remove(this.grid[x][y]);

				this.grid[x][y] = mesh;
				this.scene.add(mesh);
				return mesh;
			},

			clearPos : function(x, y){
				this.scene.remove(this.grid[x][y]);
				this.grid[x][y] = undefined;
			},

			clearMesh : function(mesh){
				this.scene.remove(mesh);
			},

			addGround : function(type, x, y){
				if(type.ground !== true)
					return;
				
				var ground = type.mesh.clone();
				ground.position.x = x;
				ground.position.z = y;

				if(this.ground[x][y] !== undefined)
					this.scene.remove(this.grid[x][y]);

				this.ground[x][y] = ground;

				this.scene.add(ground);
			}
		};

//----- MAIN
		var snake = new Snake();
		var map = new Map();
		var keyBinder = new KeyBinder();
		var renderManager = new RenderManager();
		var animationManager = new AnimationManager();

		window.addEventListener('load', function(){
			document.body.appendChild(CANVAS);

			map.updateData({
				height: 10,
				width: 10,
				spawn: {x:0, y:0},
				grid: [
					0,1,2,3,4, 10,11,12,13,14,
					0,0,0,0,0, 0,0,0,0,0,
					0,0,1,1,1, 0,0,0,0,0,
					0,0,0,1,1, 0,0,0,0,0,
					0,0,1,0,1, 0,0,0,1,0,

					0,1,0,0,0, 1,0,1,0,0,
					0,0,0,0,0, 1,1,0,0,0,
					0,0,0,0,0, 1,1,1,0,0,
					0,0,0,0,0, 0,0,0,0,0,
					0,0,0,0,0, 0,0,0,0,0
				]});

			renderManager.cam.position.y = 2;
			renderManager.cam.position.x = 0;
			renderManager.cam.position.z = .5;
			renderManager.cam.rotation.order = 'YXZ';
			renderManager.cam.rotation.x = -Math.PI/32*14;
			renderManager.cam.rotation.y = -Math.PI/32;

			renderManager.startUpdate();
		}, false);
	</script>
</head>
<body>
</body>
</html>