<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>SnakeColor</title>
	<style>
		body{
			margin:0px;
		}

	</style>
	<script type="text/javascript" charset="UTF-8" src="three.min.js"></script>
	<script>
		var V3 = THREE.Vector3;
		var F3 = THREE.Face3;
		var CANVAS;
		var COLOR = {
			BLACK: 0,
			GREEN: 1,
			RED: 2,
			YELLOW: 3,
			BLUE: 4,
			CYAN: 5,
			VIOLET: 6,
			WHITE: 7,
			RGB:[
				new V3(0,0,0),
				new V3(0,255,0),
				new V3(255,0,0),
				new V3(255,255,0),
				new V3(0,0,255),
				new V3(0,255,255),
				new V3(255,0,255),
				new V3(255,255,255)
			]
		};



		function Sneak(){
			this.pos = {x: 0, y: 0};
			this.maxLength = 5;
			this.speed = 250;

			this.parts = [];
			this.color = COLOR.GREEN;
		}

		Sneak.prototype = {
			growUp : function(){
				this.maxLength++;
			},

			update : function(){
				switch(keybinder.stat.dir){
					case 0: this.pos.y++;
						break;
					case 1: this.pos.x--;
						break;
					case 2: this.pos.y--;
						break;
					case 3: this.pos.x++;
						break;
				}

				if(! map.moveIn(this)){
				}
			},

			reset : function(){
				this.maxLength = 5;
				this.parts = [];
				this.color = COLOR.GREEN;
			}
		};

		var sneak = new Sneak();

		function Map(){
			this.currentData = null;
			this.grid = [];
			this.entities = [];
			this.ld = {};

			this.height = 0;
			this.width = 0;

			this.spawn = {x: 0, y: 0};
		}

		Map.prototype = {
			updateData : function(ld){//ld=> LevelData TODO basic
				this.ld = ld;

				this.height = ld.height;
				this.width = ld.width;

				this.grid = [];
				for(var i=-1, endI=his.width+1, endJ=this.height+1;  i<endI;  i++){
					this.grid.push([]);

					for(var j=-1; j<endJ; j++)
						this.grid[i].push(
								(i===0 || j===0 || i===this.width || j===this.height) ?
									1 : 0
							);
				}


			},

			clearEntity : function(pos){
				delete this.entities[pos.x][pos.y];
			},

			loadEntities : function(){
				this.entities = [];
				for(var i=-1, endI=his.width+1, endJ=this.height+1;  i<endI;  i++){
					this.entities.push([]);

					for(var j=-1; j<endJ; j++)
						if(j>-1 && j)
						this.entities[i].push(this.ld.entities[]


			}
		};

		var map = new Map();

		function KeyBinder(){

			this.dir = -1;
			this.paused = false;

			window.addEventListener('keydown', function(e){
				switch(e.keyCode){
					case 69: case 87: case 38:
							this.dir = 0;
						break;

					case 83: case 40:
							this.dir = 2;
						break;

					case 81: case 65: case 37:
							this.dir = 1;
						break;

					case 68: case 39:
							this.dir = 3;
						break;

					case 80:
							//TODO pause
						break;
				}
			}, false);
		}

		KeyBinder.prototype = {
			bind : function(type, call){


			}
		};

		var keyBinder = new KeyBinder();

		function Animation(){



		}

		Animation.prototype = {

		};


		var GEO = {
			dot :(function(){
				var geo = new THREE.Geometry();
				geo.vertices = convertArray([
					-.1, .1, -.1,
					-.1, .1,  .1, 
					 .1, .1,  .1,
					 .1, .1, -.1,

					-.1, .0, -.1,
					-.1, .0,  .1,
					 .1, .0,  .1,
					 .1, .0, -.1
				], THREE.Vector3);

				geo.faces = convertArray([
					0,1,2, 0,2,3,
					0,4,5, 0,5,1,
					1,5,6, 1,6,2,
					2,6,7, 2,7,3,
					3,7,4, 3,4,0,
					5,4,7, 5,7,6 
				], THREE.Face3)
				return geo;
			})(),

			colorSwaper : (function(){
				var geo = new THREE.Geometry();
				geo.vertices = convertArray([
					-.2, .05, -.2,
					-.2, .05,  .2, 
					 .2, .05,  .2,
					 .2, .05, -.2,

					-.4,  0, -.4,
					-.4,  0,  .4,
					 .4,  0,  .4,
					 .4,  0, -.4,

					-.45, -.049, -.45,
					-.45, -.049,  .45,
					 .45, -.049,  .45,
					 .45, -.049, -.45
				], THREE.Vector3);

				geo.faces = convertArray([
					0,4,5, 0,5,1,
					1,5,6, 1,6,2,
					2,6,7, 2,7,3,
					3,7,4, 3,4,0,

					0,5,4, 0,1,5,
					1,6,5, 1,2,6,
					2,7,6, 2,3,7,
					3,4,7, 3,0,4,

					4,8,9,   4,9,5,
					5,9,10,  5,10,6,
					6,10,11, 6,11,7,
					7,11,8,  7,8,4

				], THREE.Face3);

				return geo;
			})(),

			ground : (function(){
				var geo = new THREE.Geometry();
				geo.vertices = convertArray([
					-.4,  0, -.4,
					-.4,  0,  .4,
					 .4,  0,  .4,
					 .4,  0, -.4,

					-.5, -.1, -.5,  
					-.5, -.1,  .5, 
					 .5, -.1,  .5, 
					 .5, -.1, -.5
				], THREE.Vector3);

				geo.faces = convertArray([
					0,1,2, 0,2,3,
					0,4,5, 0,5,1,
					1,5,6, 1,6,2,
					2,6,7, 2,7,3,
					3,7,4, 3,4,0
				], THREE.Face3);

				return geo;
			})(),

			wall : (function(){
				var geo = new THREE.Geometry();
				geo.vertices = convertArray([
					-.4,  .4, -.4,
					-.4,  .4,  .4,
					 .4,  .4,  .4,
					 .4,  .4, -.4,

					-.5,  .3, -.5,
					-.5,  .3,  .5,
					 .5,  .3,  .5,
					 .5,  .3, -.5,

					-.5, -.1, -.5,
					-.5, -.1,  .5,
					 .5, -.1,  .5,
					 .5, -.1, -.5
				], THREE.Vector3);

				geo.faces = convertArray([
					0,1,2, 0,2,3,
					0,4,5, 0,5,1,
					1,5,6, 1,6,2,
					2,6,7, 2,7,3,
					3,7,4, 3,4,0,

					4,8,9,   4,9,5,
					5,9,10,  5,10,6,
					6,10,11, 6,11,7,
					7,11,8,  7,8,4
				], THREE.Face3);

				return geo;
			})()
		};

		var MAT = {
			color : function(color){
				var vert = [
					"#ifdef GL_ES",
					"precision mediump float;",
					"#endif",

					"void main(){",
						"gl_Position = projectionMatrix *modelViewMatrix *vec4(position, 1.0);",
					"}"
				].join('\n');
				var frag = [
					"#ifdef GL_ES",
					"precision mediump float;",
					"#endif",

					"uniform vec3 color;",

					"void main(void){",
						"gl_FragColor = vec4(color, 1.);",
					"}"
				].join('\n');
				var attributes = [];

				return new THREE.ShaderMaterial({
			        uniforms: {color : {type: 'v3', value: color} },
			        attributes: {},
			        vertexShader:   vert,
			        fragmentShader: frag
			    });
			},
			alphaGradient : function(list, color){
				var vert = [
					"#ifdef GL_ES",
					"precision mediump float;",
					"#endif",

		    		"varying float vAlpha;",
		    		"attribute float alpha;",

					"void main(){",
						"vAlpha = alpha;",
						"gl_Position = projectionMatrix *modelViewMatrix *vec4(position, 1.0);",
					"}"
				].join('\n');
				var frag = [
					"#ifdef GL_ES",
					"precision mediump float;",
					"#endif",

					"uniform vec3 color;",
		    		"varying float vAlpha;",

					"void main(void){",
						"gl_FragColor = vec4(color, vAlpha);",
					"}"
				].join('\n');
				var attributes = [];

				return new THREE.ShaderMaterial({
			        uniforms: {color : {type: 'v3', value: color} },
			        attributes: {alpha : {type: 'f', value: list} },
			        vertexShader:   vert,
			        fragmentShader: frag,
			        transparent: true
			    });
			},
			grayGradient : function(list){
				var vert = [
					"#ifdef GL_ES",
					"precision mediump float;",
					"#endif",

		    		"varying float vGrad;",
		    		"attribute float grad;",

					"void main(){",
						"vGrad = grad;",
						"gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0 );",
					"}"
				].join('\n');
				var frag = [
					"#ifdef GL_ES",
					"precision mediump float;",
					"#endif",

		    		"varying float vGrad;",

					"void main(void){",
						"gl_FragColor = vec4(vGrad, vGrad, vGrad,1.);",
					"}"
				].join('\n');
				var attributes = [];

				return new THREE.ShaderMaterial({
			        uniforms:       {},
			        attributes:     {
			        	grad : {type: 'f', value: list}
			        },
			        vertexShader:   vert,
			        fragmentShader: frag
			    });
			}
		};

		function convertArray(list, type){
			var r = [];//result
			for(var i=0; i<list.length; i+=3)
				r.push(new type(list[i], list[i+1], list[i+2]));

			return r;
		}

		function ColorSwaper(color, pos){
			this.color = color;
			this.mesh = this.craftMesh();
		}

		ColorSwaper.prototype =	{
			moveIn : function(sneak){
				if(sneak.color !== this.color){
					sneak.color = this.color;
				}
				return true;
			},

			craftMesh : function(){
				return new THREE.Mesh(GEO.colorSwaper, MAT.alphaGradient(this.color));
			}
		};

		function Block(height){
			this.height = height;
			this.mesh = this.craftMesh();
		}

		Block.prototype = {
			moveIn : function(sneak){
				return this.height === 0;
			},

			craftMesh : function(){
				if(this.height === 0)
					return new THREE.Mesh(GEO.ground, MAT.grayGradient([.4,.4,.4,.4, .25,.25,.25,.25]));
				else
					return new THREE.Mesh(GEO.wall, MAT.grayGradient([.4,.4,.4,.4, .25,.25,.25,.25, .25,.25,.25,.25]));
			}
		};

		function Dot(color){
			this.color = color;
			this.mesh = this.craftMesh();
		}

		Dot.prototype = {
			moveIn : function(sneak){
				if(sneak.color === this.color){
					sneak.maxLength++;

					return true;
				}	
				else
					return false;
			},

			craftMesh : function(){
				return new THREE.Mesh(GEO.dot, MAT.color(this.color));
			}
		};

		var GROUNDS = [
			new Block(0),
			new Block(1)
		];

		var ENTITIES = [
			new ColorSwaper(COLOR.BLACK),
			new ColorSwaper(COLOR.GREEN),
			new ColorSwaper(COLOR.RED),
			new ColorSwaper(COLOR.YELLOW),
			new ColorSwaper(COLOR.BLUE),
			new ColorSwaper(COLOR.CYAN),
			new ColorSwaper(COLOR.VIOLET),
			new ColorSwaper(COLOR.WHITE),

			new Dot(COLOR.BLACK),
			new Dot(COLOR.GREEN),
			new Dot(COLOR.RED),
			new Dot(COLOR.YELLOW),
			new Dot(COLOR.BLUE),
			new Dot(COLOR.CYAN),
			new Dot(COLOR.VIOLET),
			new Dot(COLOR.WHITE)
		];

		function RenderManager(){
			this.cam = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 1, 100);
			this.renderer = new THREE.WebGLRenderer({antialias: false});
   			this.scene = new THREE.Scene();
   			this.meshes = {};

			CANVAS = this.renderer.domElement;
   			this.onRun = false;
   			this.lastTick = 0;

			var self = this;
			window.onresize = function(){self.updateSize();};
   			this.updateSize();
		}

		RenderManager.prototype = {
			startUpdate : function(){
				this.onRun = true;
				this.lastTick = Date.now();
				this.update(this);
			},

			stopUpdate : function(){
				this.onRun = false;
			},

			update : function(rm){//rm => RenderManager
				var delta = Date.now() -rm.lastTick;
				rm.lastTick += delta;

				if(rm.onRun)
					requestAnimationFrame(function(){rm.update(rm);});

				rm.renderer.render(rm.scene, rm.cam);
			},

			updateSize : function(e){
				this.cam.aspect = window.innerWidth /window.innerHeight;
				this.cam.updateProjectionMatrix();

				this.renderer.setSize( window.innerWidth, window.innerHeight);
				CANVAS.style.height = window.innerHeight-5 +'px';
				CANVAS.style.width = window.innerWidth +'px';
			},

			defineMesh : function(id, pos){
				var mesh = ENTITIES[id].mesh.clone();
				mesh.position.x = pos.x;
				mesh.position.z = pos.y;

				return mesh;

				this.scene.add(mesh);
			},

			clearMesh : function(mesh){
				this.scene

			}
		};

		var renderManager = new RenderManager();

		window.addEventListener('load', function(){
			document.body.appendChild(CANVAS);

			var geo = GEO.wall;
			geo.computeFaceNormals();
			geo.computeVertexNormals();


			for(var i=0; i<20; i++)
				for(var j=0; j<20; j++){

				if(i === 0 || j === 0 || i===19 || j===19){
					var object = new THREE.Mesh(GEO.wall , MAT.grayGradient([.4,.4,.4,.4, .25,.25,.25,.25, .25,.25,.25,.25]));
					object.position.x = i-10;
					object.position.z = j-10;
					renderManager.scene.add(object);

				}else{
					var object = new THREE.Mesh(GEO.ground , MAT.grayGradient([.4,.4,.4,.4, .25,.25,.25,.25]));
					object.position.x = i-10;
					object.position.z = j-10;
					renderManager.scene.add(object);

					var object = new THREE.Mesh(GEO.dot , MAT.color(COLOR.RGB[i%COLOR.WHITE]));
					object.position.x = i-10;
					object.position.z = j-10;
					renderManager.scene.add(object);
				}
			}

			renderManager.cam.position.y = 3;
			renderManager.cam.position.z = 10;
			renderManager.cam.rotation.x = -Math.PI/5;

			renderManager.renderer.render(renderManager.scene, renderManager.cam);

			renderManager.startUpdate();



		}, false);

		window.addEventListener('keypress', function(e){
			switch(e.keyCode){
				case 101: renderManager.cam.position.z--;
				break;
				case 100: renderManager.cam.position.z++;
				break;
				case 115: renderManager.cam.position.x--;
				break;
				case 102: renderManager.cam.position.x++;
				break;
				case 122: renderManager.cam.position.y--;
				break;
				case 114: renderManager.cam.position.y++;
				break;
			}


		}, false);
	</script>
</head>
<body>
</body>
</html>