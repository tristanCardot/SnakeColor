<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>SnakeColor</title>
	<style>
		body{
			margin:0px;
		}

	</style>
	<script type="text/javascript" charset="UTF-8" src="three.min.js"></script>
	<script>

//----- STATIC
		var V3 = THREE.Vector3;
		var F3 = THREE.Face3;
		var CANVAS;
		var COLOR = {
			BLACK: 0,
			GREEN: 1,
			RED: 2,
			YELLOW: 3,
			BLUE: 4,
			CYAN: 5,
			VIOLET: 6,
			WHITE: 7,

			RGB:[
				new V3(0,0,0),
				new V3(0,255,0),
				new V3(255,0,0),
				new V3(255,255,0),
				new V3(0,0,255),
				new V3(0,255,255),
				new V3(255,0,255),
				new V3(255,255,255)
			]
		};

		var GEO = {
			dot :(function(){
				var geo = new THREE.Geometry();
				geo.vertices = convertArray([
					-.1, .1, -.1,
					-.1, .1,  .1, 
					 .1, .1,  .1,
					 .1, .1, -.1,

					-.1, .0, -.1,
					-.1, .0,  .1,
					 .1, .0,  .1,
					 .1, .0, -.1
				], THREE.Vector3);

				geo.faces = convertArray([
					0,1,2, 0,2,3,
					0,4,5, 0,5,1,
					1,5,6, 1,6,2,
					2,6,7, 2,7,3,
					3,7,4, 3,4,0,
					5,4,7, 5,7,6 
				], THREE.Face3)
				return geo;
			})(),

			colorSwaper : (function(){
				var geo = new THREE.Geometry();
				geo.vertices = convertArray([
					-.2, .05, -.2,
					-.2, .05,  .2, 
					 .2, .05,  .2,
					 .2, .05, -.2,

					-.4,  0, -.4,
					-.4,  0,  .4,
					 .4,  0,  .4,
					 .4,  0, -.4,

					-.45, -.049, -.45,
					-.45, -.049,  .45,
					 .45, -.049,  .45,
					 .45, -.049, -.45
				], THREE.Vector3);

				geo.faces = convertArray([
					0,4,5, 0,5,1,
					1,5,6, 1,6,2,
					2,6,7, 2,7,3,
					3,7,4, 3,4,0,

					0,5,4, 0,1,5,
					1,6,5, 1,2,6,
					2,7,6, 2,3,7,
					3,4,7, 3,0,4,

					4,8,9,   4,9,5,
					5,9,10,  5,10,6,
					6,10,11, 6,11,7,
					7,11,8,  7,8,4

				], THREE.Face3);

				return geo;
			})(),

			ground : (function(){
				var geo = new THREE.Geometry();
				geo.vertices = convertArray([
					-.4,  0, -.4,
					-.4,  0,  .4,
					 .4,  0,  .4,
					 .4,  0, -.4,

					-.5, -.1, -.5,  
					-.5, -.1,  .5, 
					 .5, -.1,  .5, 
					 .5, -.1, -.5
				], THREE.Vector3);

				geo.faces = convertArray([
					0,1,2, 0,2,3,
					0,4,5, 0,5,1,
					1,5,6, 1,6,2,
					2,6,7, 2,7,3,
					3,7,4, 3,4,0
				], THREE.Face3);

				return geo;
			})(),

			wall : (function(){
				var geo = new THREE.Geometry();
				geo.vertices = convertArray([
					-.4,  .4, -.4,
					-.4,  .4,  .4,
					 .4,  .4,  .4,
					 .4,  .4, -.4,

					-.5,  .3, -.5,
					-.5,  .3,  .5,
					 .5,  .3,  .5,
					 .5,  .3, -.5,

					-.5, -.1, -.5,
					-.5, -.1,  .5,
					 .5, -.1,  .5,
					 .5, -.1, -.5
				], THREE.Vector3);

				geo.faces = convertArray([
					0,1,2, 0,2,3,
					0,4,5, 0,5,1,
					1,5,6, 1,6,2,
					2,6,7, 2,7,3,
					3,7,4, 3,4,0,

					4,8,9,   4,9,5,
					5,9,10,  5,10,6,
					6,10,11, 6,11,7,
					7,11,8,  7,8,4
				], THREE.Face3);

				return geo;
			})()
		};

		var MAT = {
			color : function(color){
				var vert = [
					"#ifdef GL_ES",
					"precision mediump float;",
					"#endif",

					"void main(){",
						"gl_Position = projectionMatrix *modelViewMatrix *vec4(position, 1.0);",
					"}"
				].join('\n');
				var frag = [
					"#ifdef GL_ES",
					"precision mediump float;",
					"#endif",

					"uniform vec3 color;",

					"void main(void){",
						"gl_FragColor = vec4(color, 1.);",
					"}"
				].join('\n');
				var attributes = [];

				return new THREE.ShaderMaterial({
			        uniforms: {color : {type: 'v3', value: color} },
			        attributes: {},
			        vertexShader:   vert,
			        fragmentShader: frag
			    });
			},
			alphaGradient : function(list, color){
				var vert = [
					"#ifdef GL_ES",
					"precision mediump float;",
					"#endif",

		    		"varying float vAlpha;",
		    		"attribute float alpha;",

					"void main(){",
						"vAlpha = alpha;",
						"gl_Position = projectionMatrix *modelViewMatrix *vec4(position, 1.0);",
					"}"
				].join('\n');
				var frag = [
					"#ifdef GL_ES",
					"precision mediump float;",
					"#endif",

					"uniform vec3 color;",
		    		"varying float vAlpha;",

					"void main(void){",
						"gl_FragColor = vec4(color, vAlpha);",
					"}"
				].join('\n');
				var attributes = [];

				return new THREE.ShaderMaterial({
			        uniforms: {color : {type: 'v3', value: color} },
			        attributes: {alpha : {type: 'f', value: list} },
			        vertexShader:   vert,
			        fragmentShader: frag,
			        transparent: true
			    });
			},
			grayGradient : function(list){
				var vert = [
					"#ifdef GL_ES",
					"precision mediump float;",
					"#endif",

		    		"varying float vGrad;",
		    		"attribute float grad;",

					"void main(){",
						"vGrad = grad;",
						"gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0 );",
					"}"
				].join('\n');
				var frag = [
					"#ifdef GL_ES",
					"precision mediump float;",
					"#endif",

		    		"varying float vGrad;",

					"void main(void){",
						"gl_FragColor = vec4(vGrad, vGrad, vGrad,1.);",
					"}"
				].join('\n');
				var attributes = [];

				return new THREE.ShaderMaterial({
			        uniforms:       {},
			        attributes:     {
			        	grad : {type: 'f', value: list}
			        },
			        vertexShader:   vert,
			        fragmentShader: frag
			    });
			}
		};


//----- SNEAK
		function Sneak(){
			this.pos = {x: 0, y: 0};
			this.maxLength = 5;
			this.speed = 250;
			this.nextMove = 0;

			this.parts = [];
			this.color = COLOR.GREEN;

			this.mesh = new THREE.Mesh(GEO.wall, MAT.color(COLOR.GREEN));
		}

		Sneak.prototype = {
			growUp : function(){
				this.maxLength++;
			},

			update : function(delta){
				this.nextMove-=delta;
				if(this.nextMove>0)
					return;

				this.nextMove+=this.speed;

				switch(keyBinder.dir){
					case 0: this.pos.y++;
						break;
					case 1: this.pos.x--;
						break;
					case 2: this.pos.y--;
						break;
					case 3: this.pos.x++;
						break;
					default: return;
				}


				if(map.moveIn(this)){
					var mesh = this.renderManager.defineMesh(ENTITIES[0], this.pos.x, this.pos.y);

					this.parts.push({x: this.pos.x, y: this.pos.y, mesh:mesh});

					if(this.parts.length > this.maxLength)
						RenderManager.clearMesh( this.parts[0]);
						this.parts = this.parts.slice(1);
				}
			},

			reset : function(){
				this.maxLength = 5;
				this.parts = [];
				this.color = COLOR.GREEN;
				this.pos.x = map.spawn.x;
				this.pos.y = map.spawn.y;
			}
		};


//----- MAP
		function Map(){
			this.currentData = null;
			this.grid = [];
			this.entities = [];
			this.ld = {};

			this.height = 0;
			this.width = 0;

			this.spawn = {x: 0, y: 0};
		}

		Map.prototype = {
			updateData : function(ld){//ld=> LevelData TODO basic
				this.ld = ld;

				this.height = ld.height;
				this.width = ld.width;
				this.spawn = ld.spawn;

				renderManager.initGrid(this.height+2, this.width+2);

				this.grid = [];
				for(var i=-1, endI=this.width+1, endJ=this.height+1, length, gridS,entityS;  i<endI;  i++){
					this.grid.push([]);
					this.entities.push([]);

					length = this.grid.length-1;

					for(var j=-1; j<endJ; j++){
						if(i<0 || j<0 || i>=this.width || j>=this.height){
							gridS = GROUNDS.LIST[ GROUNDS.WALL ];
							entityS = undefined;

						}else{
							gridS = GROUNDS.LIST[ ld.grid[i *this.height +j] ];
							entityS = ENTITIES.LIST[ ld.entities[i *this.height +j] ];
						}
						
						this.grid[length].push(gridS);
						renderManager.craftGrid(gridS, i+1, j+1);

						this.entities[length].push(entityS)
						renderManager.craftEntity(entityS, i+1, j+1);
					}
				}
			},

			clearEntity : function(pos){
				var entity = this.entities[pos.x][pos.y];

				if(entity.type !== undefined){
					renderManager.clearMesh(entity);
					this.entities[pos.x][pos.y] = {};
				}
			},

			reset : function(){
				sneak.reset();

				for(var i=0,j,select; i<this.entities.length; i++){
					this.entities.push([]);

					for(j=0; j<this.height; j++){
						var select = this.ld.entities[i *this.height +j];

						if(select !== undefined){
							var mesh = renderManager.defineMesh(select);
							this.entities[i].push({type: select, mesh: mesh});

						}else
							this.entities[i].push({});
					}
				}
			}
		};


//----- KEYBINDER
		function KeyBinder(){
			this.dir = -1;
			this.paused = false;

			window.addEventListener('keydown', function(e){
				switch(e.keyCode){
					case 69: case 87: case 38:
							this.dir = 0;
						break;

					case 83: case 40:
							this.dir = 2;
						break;

					case 81: case 65: case 37:
							this.dir = 1;
						break;

					case 68: case 39:
							this.dir = 3;
						break;

					case 80:
							//TODO pause
						break;
				}
			}, false);
		}

		KeyBinder.prototype = {
			bind : function(type, call){


			}
		};


//----- ANIMATION
		function Animation(){



		}

		Animation.prototype = {

		};




		function convertArray(list, type){
			var r = [];//result
			for(var i=0; i<list.length; i+=3)
				r.push(new type(list[i], list[i+1], list[i+2]));

			return r;
		}


//----- ENTITIES CONSTRUCTOR + STATIC
		function SneakPart(sneak){
			this.color;
			this.mesh = this.craftMesh();
		}

		SneakPart.prototype = {
			moveIn : function(){
				return false;
			},

			craftMesh : function(){
				var mat = MAT.color(COLOR.GREEN);
				this.color = mat.uniforms.color;
				return new THREE.Mesh(GEO.colorSwaper, mat);
			}
		};


		function ColorSwaper(color, pos){
			this.color = color;
			this.mesh = this.craftMesh();
		}

		ColorSwaper.prototype =	{
			moveIn : function(sneak){
				if(sneak.color !== this.color){
					sneak.color = this.color;
				}
				return true;
			},

			craftMesh : function(){
				return new THREE.Mesh(GEO.colorSwaper, MAT.alphaGradient(this.color));
			}
		};

		function Block(height){
			this.height = height;
			this.mesh = this.craftMesh();
		}

		Block.prototype = {
			moveIn : function(sneak){
				return this.height === 0;
			},

			craftMesh : function(){
				if(this.height === 0)
					return new THREE.Mesh(GEO.ground, MAT.grayGradient([.4,.4,.4,.4, .25,.25,.25,.25]));
				else
					return new THREE.Mesh(GEO.wall, MAT.grayGradient([.4,.4,.4,.4, .25,.25,.25,.25, .25,.25,.25,.25]));
			}
		};

		function Dot(color){
			this.color = color;
			this.mesh = this.craftMesh();
		}

		Dot.prototype = {
			moveIn : function(sneak){
				if(sneak.color === this.color){
					sneak.maxLength++;

					return true;
				}	
				else
					return false;
			},

			craftMesh : function(){
				return new THREE.Mesh(GEO.dot, MAT.color(this.color));
			}
		};

		var GROUNDS = {
			LIST: [
				new Block(0),
				new Block(1)
			],
			GROUND: 0,
			WALL: 1
		};

		var ENTITIES = {
			LIST: [
				new SneakPart(),

				new ColorSwaper(COLOR.BLACK),
				new ColorSwaper(COLOR.GREEN),
				new ColorSwaper(COLOR.RED),
				new ColorSwaper(COLOR.YELLOW),
				new ColorSwaper(COLOR.BLUE),
				new ColorSwaper(COLOR.CYAN),
				new ColorSwaper(COLOR.VIOLET),
				new ColorSwaper(COLOR.WHITE),

				new Dot(COLOR.BLACK),
				new Dot(COLOR.GREEN),
				new Dot(COLOR.RED),
				new Dot(COLOR.YELLOW),
				new Dot(COLOR.BLUE),
				new Dot(COLOR.CYAN),
				new Dot(COLOR.VIOLET),
				new Dot(COLOR.WHITE)
			],

			SNEAK: 0,
			SWAPERBLACK: 1,
			SWAPERGREEN: 2
		};


//----- RENDERMANAGER
		function RenderManager(){
			this.cam = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 1, 100);
			this.renderer = new THREE.WebGLRenderer({antialias: false});
   			this.scene = new THREE.Scene();
   			
   			this.grid;
   			this.entities;

			CANVAS = this.renderer.domElement;
   			this.onRun = false;
   			this.lastTick = 0;

			var self = this;
			window.onresize = function(){self.updateSize();};
   			this.updateSize();
		}

		RenderManager.prototype = {
			startUpdate : function(){
				this.onRun = true;
				this.lastTick = Date.now();
				this.update(this);
			},

			stopUpdate : function(){
				this.onRun = false;
			},

			update : function(rm){//rm => RenderManager
				var delta = Date.now() -rm.lastTick;
				rm.lastTick += delta;

				if(rm.onRun)
					requestAnimationFrame(function(){rm.update(rm);});

				rm.renderer.render(rm.scene, rm.cam);
				sneak.update(delta);
			},

			updateSize : function(e){
				this.cam.aspect = window.innerWidth /window.innerHeight;
				this.cam.updateProjectionMatrix();

				this.renderer.setSize( window.innerWidth, window.innerHeight);
				CANVAS.style.height = window.innerHeight-5 +'px';
				CANVAS.style.width = window.innerWidth +'px';
			},

			initGrid : function(height, width){
				this.grid = [];
				this.entities = [];

				for(var i=0, j; i<width; i++){
					this.grid.push([]);
					this.entities.push([]);

					for(j=0; j<height; j++){
						this.grid[i].push();
						this.entities[i].push();
					}
				}
			},

			craftEntity : function(type, x, y){
				if(type === undefined)
					return;

				var mesh = type.mesh.clone();
				mesh.position.x = x;
				mesh.position.z = y;

				this.entities[x][y] = mesh;

				this.scene.add(mesh);
			},

			clearEntity : function(x, y){
				this.scene.remove(this.entities[x][y]);
				this.entities[x][y] = undefined;
			},

			craftGrid : function(type, x, y){
				if(type === undefined)
					return;

				var mesh = type.mesh.clone();
				mesh.position.x = x;
				mesh.position.z = y;

				this.entities[x][y] = mesh;

				this.scene.add(mesh);
			},
			
			clearGrid : function(x, y){
				this.scene.remove(this.grid[x][y]);
				this.grid[x][y] = undefined;
			},

		};

//----- MAIN
		var sneak = new Sneak();
		var map = new Map();
		var keyBinder = new KeyBinder();
		var renderManager = new RenderManager();

		window.addEventListener('load', function(){
			document.body.appendChild(CANVAS);

			/*
			var geo = GEO.wall;
			geo.computeFaceNormals();
			geo.computeVertexNormals();

			for(var i=0; i<20; i++)
				for(var j=0; j<20; j++){

				if(i === 0 || j === 0 || i===19 || j===19){
					var object = new THREE.Mesh(GEO.wall , MAT.grayGradient([.4,.4,.4,.4, .25,.25,.25,.25, .25,.25,.25,.25]));
					object.position.x = i-10;
					object.position.z = j-10;
					renderManager.scene.add(object);

				}else{
					var object = new THREE.Mesh(GEO.ground , MAT.grayGradient([.4,.4,.4,.4, .25,.25,.25,.25]));
					object.position.x = i-10;
					object.position.z = j-10;
					renderManager.scene.add(object);

					var object = new THREE.Mesh(GEO.dot , MAT.color(COLOR.RGB[i%COLOR.WHITE]));
					object.position.x = i-10;
					object.position.z = j-10;
					renderManager.scene.add(object);
				}
			}*/

			map.updateData({
				height: 20,
				width: 30,
				grid: [ 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0





				], 
				entities: [
					0,0,0,0,0,0,0,0,0,0

				] 
			});

			renderManager.cam.position.y = 3;
			renderManager.cam.position.z = 10;
			renderManager.cam.rotation.x = -Math.PI/5;

			renderManager.startUpdate();
		}, false);

		window.addEventListener('keypress', function(e){
			switch(e.keyCode){
				case 101: renderManager.cam.position.z--;
				break;
				case 100: renderManager.cam.position.z++;
				break;
				case 115: renderManager.cam.position.x--;
				break;
				case 102: renderManager.cam.position.x++;
				break;
				case 122: renderManager.cam.position.y--;
				break;
				case 114: renderManager.cam.position.y++;
				break;
			}


		}, false);
	</script>
</head>
<body>
</body>
</html>