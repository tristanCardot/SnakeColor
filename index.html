<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>SnakeColor</title>
	<style>
		body{
			overflow:hidden;
			margin:0px;
		}



	</style>
	<script type="text/javascript" charset="UTF-8" src="three.min.js"></script>
	<script>

//- STATIC
		var SCREENY = 0,
			FOV = 75,
			V3 = THREE.Vector3,
			F3 = THREE.Face3,
			CANVAS,
			COLOR = {
			BLACK: 0,
			GREEN: 1,
			RED: 2,
			YELLOW: 3,
			BLUE: 4,
			CYAN: 5,
			VIOLET: 6,
			WHITE: 7,

			RGB:[
				new V3(0,0,0),
				new V3(1/255*40, 1/255*180, 1/255*20),
				new V3(1,0,0),
				new V3(1,1,0),
				new V3(0,0,1),
				new V3(0,1,1),
				new V3(1,0,1),
				new V3(1,1,1)
			]
		};

		var GEO = {
			snakePart: (function(){
				var geo = new THREE.Geometry();
				geo.vertices = convertArray([
					-.4, .4, -.4,
					-.4, .4,  .4, 
					 .4, .4,  .4,
					 .4, .4, -.4,

					-.4, .4, -.4,
					-.4, .0, -.4,
					-.4, .0,  .4,
					-.4, .4,  .4, 

					-.4, .4,  .4, 
					-.4, .0,  .4,
					 .4, .0,  .4,
					 .4, .4,  .4,

					 .4, .4,  .4,
					 .4, .0,  .4,
					 .4, .0, -.4,
					 .4, .4, -.4,

					 .4, .4, -.4,
					 .4, .0, -.4,
					-.4, .0, -.4,
					-.4, .4, -.4
				], THREE.Vector3);

				geo.faces = convertArray([
					0,1,2,    0,2,3,
					4,5,6,    4,6,7,
					8,9,10,   8,10,11,
					12,13,14, 12,14,15,
					16,17,18, 16,18,19
				], THREE.Face3);
				return geo;
			})(),

			dot: (function(){
				var geo = new THREE.Geometry();
				geo.vertices = convertArray([
					-.1, .1, -.1,
					-.1, .1,  .1, 
					 .1, .1,  .1,
					 .1, .1, -.1,

					-.1, .0, -.1,
					-.1, .0,  .1,
					 .1, .0,  .1,
					 .1, .0, -.1
				], THREE.Vector3);

				geo.faces = convertArray([
					0,1,2, 0,2,3,
					0,4,5, 0,5,1,
					1,5,6, 1,6,2,
					2,6,7, 2,7,3,
					3,7,4, 3,4,0,
					5,4,7, 5,7,6 
				], THREE.Face3);
				return geo;
			})(),

			colorSwaper: (function(){
				var geo = new THREE.Geometry();
				geo.vertices = convertArray([
					-.0, 0, -.0,
					-.0, 0,  .0, 
					 .0, 0,  .0,
					 .0, 0, -.0,

					-.2,  .1, -.2,
					-.2,  .1,  .2,
					 .2,  .1,  .2,
					 .2,  .1, -.2,

					-.4, 0, -.4,
					-.4, 0,  .4,
					 .4, 0,  .4,
					 .4, 0, -.4
				], THREE.Vector3);

				geo.faces = convertArray([
					0,4,5, 0,5,1,
					1,5,6, 1,6,2,
					2,6,7, 2,7,3,
					3,7,4, 3,4,0,

					0,5,4, 0,1,5,
					1,6,5, 1,2,6,
					2,7,6, 2,3,7,
					3,4,7, 3,0,4,

					4,8,9,   4,9,5,
					5,9,10,  5,10,6,
					6,10,11, 6,11,7,
					7,11,8,  7,8,4

				], THREE.Face3);

				return geo;
			})(),

			ground: (function(){
				var geo = new THREE.Geometry();
				geo.vertices = convertArray([
					-.4,  0, -.4,
					-.4,  0,  .4,
					 .4,  0,  .4,
					 .4,  0, -.4,

					-.4,   0, -.4,
					-.5, -.1, -.5,
					-.5, -.1,  .5,
					-.4,   0,  .4,

					-.4,   0,  .4,
					-.5, -.1,  .5,
					 .5, -.1,  .5,
					 .4,   0,  .4,

					 .4,   0,  .4,
					 .5, -.1,  .5,
					 .5, -.1, -.5,
					 .4,   0, -.4,

					 .4,   0, -.4,
					 .5, -.1, -.5,
					-.5, -.1, -.5,
					-.4,   0, -.4
				], THREE.Vector3);

				geo.faces = convertArray([
					0,1,2,    0,2,3,
					4,5,6,    4,6,7,
					8,9,10,   8,10,11,
					12,13,14, 12,14,15,
					16,17,18, 16,18,19
				], THREE.Face3);

				return geo;
			})(),

			

			wall: (function(){
				var geo = new THREE.Geometry();
				geo.vertices = convertArray([
					-.4,.4,-.4,  -.4,.4,.4,  .4,.4,.4,  .4,.4,-.4,

					-.4,.4,-.4,  -.5,.3,-.4,  -.5,.3,.4,  -.4,.4,.4,
					-.4,.4,.4,  -.4,.3,.5,  .4,.3,.5,  .4,.4,.4,
					.4,.4,.4,  .5,.3,.4,  .5,.3,-.4,  .4,.4,-.4,
					.4,.4,-.4,  .4,.3,-.5,  -.4,.3,-.5,  -.4,.4,-.4,

					-.4,.4,-.4, -.4,.3,-.5, -.5,.3,-.4,
					-.4,.4,.4, -.5,.3,.4, -.4,.3,.5,
					.4,.4,.4,  .4,.3,.5,  .5,.3,.4,
					.4,.4,-.4, .5,.3,-.4, .4,.3,-.5,

					-.5,.3,-.4,  -.5,-.1,-.4,  -.5,-.1,.4,  -.5,.3,.4,
					-.4,.3,.5,  -.4,-.1,.5,  .4,-.1,.5,  .4,.3,.5,
					.5,.3,.4,  .5,-.1,.4,  .5,-.1,-.4,  .5,.3,-.4,
					.4,.3,-.5,  .4,-.1,-.5,  -.4,-.1,-.5,  -.4,.3,-.5,

					-.4,.3,-.5, -.4,-.1,-.5, -.5,-.1,-.4, -.5,.3,-.4,
					 -.5,.3,.4, -.5,-.1,.4, -.4,-.1,.5, -.4,.3,.5,
					.4,.3,.5, .4,-.1,.5, .5,-.1,.4, .5,.3,.4,
					.5,.3,-.4, .5,-.1,-.4, .4,-.1,-.5, .4,.3,-.5,

					-.5,-.1,-.5, -.5,-.1,-.4, -.4,-.1,-.5,
					-.5,-.1,.5, -.4,-.1,.5, -.5,-.1,.4,
					.5,-.1,.5, .5,-.1,.4, .4,-.1,.5,
					.5,-.1,-.5, .4,-.1,-.5, .5,-.1,-.4
				], THREE.Vector3);

				geo.faces = convertArray([
					0,1,2,    0,2,3,
					4,5,6,    4,6,7,
					8,9,10,   8,10,11,
					12,13,14, 12,14,15,
					16,17,18, 16,18,19,

					20,21,22, 23,24,25,
					26,27,28, 29,30,31,

					32,33,34, 32,34,35,
					36,37,38, 36,38,39,
					40,41,42, 40,42,43,
					44,45,46, 44,46,47,

					48,49,50, 48,50,51,
					52,53,54, 52,54,55,
					56,57,58, 56,58,59,
					60,61,62, 60,62,63,

					64,65,66, 67,68,69,
					70,71,72, 73,74,75

				], THREE.Face3);

				return geo;
			})()
		};

		var MAT = {
			sneakColor : (function(){
				var vert = [
					"#ifdef GL_ES",
					"precision mediump float;",
					"#endif",

					"attribute float saturation;",
					"varying float vSaturation;",

					"void main(){",
						"vSaturation = saturation;",
						"gl_Position = projectionMatrix *modelViewMatrix *vec4(position, 1.0);",
					"}"
				].join('\n');
				var frag = [
					"#ifdef GL_ES",
					"precision mediump float;",
					"#endif",

					"uniform vec3 color;",
					"varying float vSaturation;",

					"void main(void){",
						"gl_FragColor = vec4(color *vSaturation, 1.);",
					"}"
				].join('\n');

				return new THREE.ShaderMaterial({
					uniforms: {color : {type: 'v3', value: new V3(0,0,0)} },
					attributes: {saturation : {type: 'f', value: [
						.75, .75, .75, .75,
						  1,   1,   1,   1,
						 .9,  .9,  .9,  .9,
						 .6,  .6,  .6,  .6,
						.45, .45, .45, .45
					]} },
					vertexShader:   vert,
					fragmentShader: frag
				});
			})(),

			color : (function(){
				var vert = [
					"#ifdef GL_ES",
					"precision mediump float;",
					"#endif",

					"void main(){",
						"gl_Position = projectionMatrix *modelViewMatrix *vec4(position, 1.0);",
					"}"
				].join('\n');
				var frag = [
					"#ifdef GL_ES",
					"precision mediump float;",
					"#endif",

					"uniform vec3 color;",

					"void main(void){",
						"gl_FragColor = vec4(color, 1.);",
					"}"
				].join('\n');
				var attributes = [];

				return new THREE.ShaderMaterial({
			        uniforms: {color : {type: 'v3', value: new V3(0,0,0)} },
			        attributs : {},
			        vertexShader:   vert,
			        fragmentShader: frag
			    });
			})(),

			alphaGradient : (function(){
				var vert = [
					"#ifdef GL_ES",
					"precision mediump float;",
					"#endif",

		    		"varying float vAlpha;",
		    		"attribute float alpha;",

					"void main(){",
						"vAlpha = alpha;",
						"gl_Position = projectionMatrix *modelViewMatrix *vec4(position, 1.0);",
					"}"
				].join('\n');
				var frag = [
					"#ifdef GL_ES",
					"precision mediump float;",
					"#endif",

					"uniform vec3 color;",
		    		"varying float vAlpha;",

					"void main(void){",
						"gl_FragColor = vec4(color, vAlpha);",
					"}"
				].join('\n');
				var attributes = [];

				return new THREE.ShaderMaterial({
			        uniforms: {color : {type: 'v3', value: new V3(0,0,0)} },
			        attributes: {alpha : {type: 'f', value: [-.5,-.5,-.5,-.5, .75,.75,.75,.75, 0,0,0,0]} },
			        vertexShader:   vert,
			        fragmentShader: frag,
			        transparent: true
			    });
			})(),

			grayGradient : (function(){
				var vert = [
					"#ifdef GL_ES",
					"precision mediump float;",
					"#endif",

		    		"varying float vGrad;",
		    		"attribute float grad;",

					"void main(){",
						"vGrad = grad;",
						"gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0 );",
					"}"
				].join('\n');
				var frag = [
					"#ifdef GL_ES",
					"precision mediump float;",
					"#endif",

		    		"varying float vGrad;",

					"void main(void){",
						"gl_FragColor = vec4(vGrad, vGrad, vGrad,1.);",
					"}"
				].join('\n');
				var attributes = [];

				return new THREE.ShaderMaterial({
			        uniforms: {},
			        attributes: {
			        	grad : {type: 'f', value: []}
			        },
			        vertexShader:   vert,
			        fragmentShader: frag
			    });
			})()
		};

		function convertArray(list, type, length){
			var r = [];//result

				for(var i=0; i<list.length; i+=3)
					r.push(new type(list[i], list[i+1], list[i+2]));

			return r;
		}


//- SNAKE
		function Snake(){
			this.pos = {x: 0, y: 0};
			this.maxLength = 5;
			this.speed = 400;
			this.nextMove = 0;

			this.dir = -1;
			this.parts = [];
			this.color = COLOR.GREEN;
			this.mat = TYPE.LIST[ TYPE.SNAKE].mesh.material;
		}

		Snake.prototype = {
			growUp : function(){
				this.maxLength++;
			},

			setDir : function(newDir){
				var lastPart = this.parts[this.parts.length-2];
				if(lastPart === undefined){
					this.dir = newDir;
					return;
				}

				switch(newDir){
					case 0:
							if(this.pos.x !== lastPart.x || this.pos.y !== lastPart.y+1)
								this.dir = newDir;
						break;
					case 1:
							if(this.pos.y !== lastPart.y || this.pos.x !== lastPart.x+1)
								this.dir = newDir;
						break;
					case 2:
							if(this.pos.x !== lastPart.x || this.pos.y !== lastPart.y-1)
								this.dir = newDir;
						break;
					case 3:
							if(this.pos.y !== lastPart.y || this.pos.x !== lastPart.x-1)
								this.dir = newDir;
						break;
				}
			},

			update : function(delta){
				this.nextMove-=delta;
				if(this.nextMove>0)
					return;

				this.nextMove+=this.speed;

				switch(this.dir){
					case 0: this.pos.y--;
						break;
					case 1: this.pos.x--;
						break;
					case 2: this.pos.y++;
						break;
					case 3: this.pos.x++;
						break;
					default: return;
				}

				if(this.parts.length > this.maxLength){
					var part = this.parts[0];
					var mesh = renderManager.grid[part.x][part.y];

					map.clearPos(part.x, part.y);
					this.parts = this.parts.splice(1);

					animationManager.pushAnimation(mesh, {
						'position': {from: new V3(part.x, 0, part.y), to: new V3(this.parts[0].x, 0, this.parts[0].y)},
						'scale': {from: new V3(1,1,1), to: new V3(.1,.1,.1)}
					}, this.speed, 0,
					function(mesh){renderManager.clearMesh(mesh);});
				}
				if(map.moveIn(this)){

					var lastPart = this.parts[this.parts.length-1];

					var mesh = renderManager.craftMesh(TYPE.LIST[TYPE.SNAKE], this.pos.x, this.pos.y);
					var vx = (this.dir === 1 ? 1 : this.dir === 3 ? -1 : 0);
					var vz = (this.dir === 0 ? 1 : this.dir === 2 ? -1 : 0);

					animationManager.pushAnimation(mesh, {
						'position': {from: new V3(this.pos.x +vx *.6, 0, this.pos.y +vz *.6), to: mesh.position.clone()},
						'scale': {from: new V3(.1,.1,.1), to: new V3(1,1,1)}
					}, this.speed, 0);

					var camP = renderManager.cam.position.clone();

					animationManager.pushAnimation(renderManager.cam, {
						'position': {from: camP, to: new V3(this.pos.x, camP.y, this.pos.y+.75)}
					}, this.speed, 0);

					this.parts.push({x: this.pos.x, y: this.pos.y});
					map.setPos(this.pos.x, this.pos.y, TYPE.LIST[TYPE.SNAKE]);
				}else
					map.reset();
			},

			reset : function(){
				this.maxLength = 5;
				this.parts = [map.spawn];
				this.dir = -1;

				this.color = COLOR.GREEN;
				this.pos.x = map.spawn.x;
				this.pos.y = map.spawn.y;

				var mesh = renderManager.craftMesh(TYPE.LIST[TYPE.SNAKE], map.spawn.x, map.spawn.y);
				this.mat.uniforms.color.value = COLOR.RGB[ this.color];

				animationManager.pushAnimation(mesh, {
					'scale': {from: new V3(.05,.05,.05), to: new V3(1,1,1)}
				},400, 0);

				map.grid[map.spawn.x][map.spawn.y] = TYPE.LIST[TYPE.SNAKE];
				keyBinder.paused = false;
			}
		};


//- MAP
		function Map(){
			this.currentData = null;
			this.grid = [];
			this.ld = {};

			this.height = 0;
			this.width = 0;
			this.dotCount = 0;
			this.spawn = {x: 0, y: 0};
		}

		Map.prototype = {
			updateData : function(ld){//ld=> LevelData TODO basic
				this.ld = ld;

				this.height = ld.height;
				this.width = ld.width;
				this.dotCount = ld.dotCount;
				this.spawn = {x: ld.spawn.x+1, y: ld.spawn.y+1};

				renderManager.initGrid(this.height+2, this.width+2);

				this.grid = [];
				for(var i=-1, endI=this.width+1, endJ=this.height+1, length, select;  i<endI;  i++){
					this.grid.push([]);

					length = this.grid.length-1;

					for(var j=-1; j<endJ; j++){
						if(i<0 || j<0 || i>=this.width || j>=this.height)
							select = TYPE.LIST[ TYPE.WALL ];
						else
							select = TYPE.LIST[ ld.grid[i +j*ld.width] ];


						if(select !== undefined){
							if(select.ground === true)
								renderManager.addGround(select, i+1, j+1);

							else{
								renderManager.craftMesh(select, i+1, j+1);
								renderManager.addGround(TYPE.LIST[TYPE.GROUND], i+1, j+1);
							}

							this.grid[i+1].push(select);

						}else{
							this.grid[i+1].push(TYPE.LIST[TYPE.GROUND]);
							renderManager.addGround(TYPE.LIST[TYPE.GROUND], i+1, j+1);
						}
					}
				}

				snake.reset();
			},

			moveIn : function(snake){
				return this.grid[snake.pos.x][snake.pos.y].moveIn(snake, renderManager.grid[snake.pos.x][snake.pos.y]);
			},

			clearPos : function(x, y){
				this.grid[x][y] = TYPE.LIST[TYPE.GROUND];
			},

			setPos : function(x, y, type){
				this.grid[x][y] = type;
			},

			reset : function(){
				keyBinder.paused = true;
				snake.dir = -1;

				this.dotCount = this.ld.dotCount;

				for(var i= (snake.parts.length>25 ? snake.parts.length-25 : 0); i<snake.parts.length; i++){
					var mesh = renderManager.grid[snake.parts[i].x][snake.parts[i].y];

					animationManager.pushAnimation(mesh, {
						'rotation' : {from: new V3(0,0,0), to: new V3(0, Math.PI*1.5, 0)},
						'scale' : {from: new V3(1,1,1), to: new V3(0.05, 0.05, 0.05)}
					}, 400, i*50,
					function(mesh){renderManager.clearMesh(mesh);});
				}

				animationManager.pushAnimation(renderManager.cam, {
						'position': {from: renderManager.cam.position.clone(), to: new V3(map.spawn.x, renderManager.cam.position.y, map.spawn.y+.5)}
					}, 250, Math.min(25, snake.parts.length) *50+200,
					function(){
						renderManager.clearGrid();

						for(var i=0, j; i<map.width; i++)
							for(var j=0; j<map.height; j++){
								select = TYPE.LIST[ map.ld.grid[i +j *map.width] ];

								if(select !== undefined)
									if(select.ground !== true){
										renderManager.craftMesh(select, i+1, j+1);
										map.grid[i+1][j+1] = select;

									}else{
										renderManager.clearPos(i+1, j+1);
										map.grid[i+1][j+1] = select;
									}
							}

						snake.reset();
					});
			}
		};


//- KEYBINDER
		function KeyBinder(){
			this.paused = false;

			var self = this;
			window.addEventListener('keydown', function(e){
				if(self.paused)
					return;

				switch(e.keyCode){
					case 90: case 87: case 38:
							snake.setDir(0);
						break;

					case 83: case 40:
							snake.setDir(2);
						break;

					case 81: case 65: case 37:
							snake.setDir(1);
						break;

					case 68: case 39:
							snake.setDir(3);
						break;

					case 80:
							//TODO pause
						break;
				}
			}, false);
		}

		KeyBinder.prototype = {
			bind : function(type, call){


			}
		};


//- ANIMATION
		function AnimationManager(){
			this.list = [];
		}

		AnimationManager.prototype = {
			pushAnimation : function(mesh, param, duration, delay, callback){
				if(mesh != null)
					this.list.push(new Animation(mesh, param, duration, delay, callback));
			},

			update : function(delta){
				for(var i=0; i<this.list.length; i++)
					if(this.list[i].update(delta)){
						this.list.splice(i,1);
						i--;
					}
			}
		};

		function Animation(mesh, param, duration, delay, callback){
			this.mesh = mesh;
			this.param = param;
			this.duration = duration;
			this.delay = delay || 0;
			this.callback = callback;

			if(this.delay === 0)
				for(key in this.param)
					this.mesh[key].set(
						this.param[key].from.x,
						this.param[key].from.y,
						this.param[key].from.z
					);
		}

		Animation.prototype = {
			update : function(delta){
				this.delay -= delta;

				if(this.delay>0)
					return;

				var off = -this.delay/ this.duration;

				if(off>1)
					off = 1;

				var offN = 1-off;

				for(key in this.param)
					this.mesh[key].set(
						this.param[key].from.x *offN + this.param[key].to.x *off,
						this.param[key].from.y *offN + this.param[key].to.y *off,
						this.param[key].from.z *offN + this.param[key].to.z *off
					);

				if(off === 1){
					if(this.callback)
						this.callback(this.mesh);
					return true;
				}

				return false;
			}
		};


//- ENTITIES CONSTRUCTOR + STATIC
		function SnakePart(){
			this.color;
			this.mesh = this.craftMesh();
		}

		SnakePart.prototype = {
			moveIn : function(){
				return false;
			},

			craftMesh : function(){
				var mat = MAT.sneakColor.clone();
				this.color = mat.uniforms.color.value = COLOR.RGB[ COLOR.GREEN ];

				return new THREE.Mesh(GEO.snakePart, mat);
			}
		};


		function ColorSwaper(color, pos){
			this.color = color;
			this.mesh = this.craftMesh();
		}

		ColorSwaper.prototype =	{
			moveIn : function(snake, mesh){
				if(snake.color !== this.color){
					snake.color = this.color;
					snake.mat.uniforms.color.value = COLOR.RGB[ this.color];
				}

				animationManager.pushAnimation(
					mesh,{
						'scale' : {from: new V3(1,1,1), to: new V3(.05,.05,.05)}
					}, 500, 0, function(mesh){
						renderManager.clearMesh(mesh);
					});

				return true;
			},

			craftMesh : function(){
				var mat = MAT.alphaGradient.clone();
				mat.uniforms.color.value = COLOR.RGB[this.color];

				return new THREE.Mesh(GEO.colorSwaper, mat);
			}
		};

		function Block(height){
			this.height = height;
			this.mesh = this.craftMesh();
			this.ground = true;
		}

		Block.prototype = {
			moveIn : function(snake){
				return this.height === 0;
			},

			craftMesh : function(){
				var mat = MAT.grayGradient.clone(),
					geo;

				if(this.height === 0){
					geo = GEO.ground;
					mat.attributes = {grad: {type:'f', value:[.35,.35,.35,.35, .45,.45,.45,.45, .40,.40,.40,.40, .3,.3,.3,.3, .25,.25,.25,.25]}};

				}else{
					geo = GEO.wall;
					mat.attributes = {grad: {type:'f', value:[
						.25,.25,.25,.25,

						.35,.35,.35,.35,
						.30,.30,.30,.30,
						.2,.2,.2,.2,
						.15,.15,.15,.15,

						.25,.25,.25,
						.325,.325,.325,
						.25,.25,.25,
						.175,.175,.175,

						.4,.4,.4,.4,
						.35,.35,.35,.35,
						.25,.25,.25,.25,
						.2,.2,.2,.2,

						.3,.3,.3,.3,
						.375,.375,.375,.375,
						.3,.3,.3,.3,
						.225,.225,.225,.225,

						.35,.35,.35,
						.35,.35,.35,
						.35,.35,.35,
						.35,.35,.35
					]}};
				}

				return new THREE.Mesh(geo, mat);
			}
		};

		function Dot(color){
			this.color = color;
			this.mesh = this.craftMesh();
		}

		Dot.prototype = {
			moveIn : function(snake, mesh){
				if(snake.color === this.color){
					snake.maxLength++;
					map.dotCount--;

					animationManager.pushAnimation(
					mesh,{
						'rotation' : {from: new V3(0,0,0), to: new V3(0,Math.PI,0)}
					}, 500, 0, function(mesh){
						renderManager.clearMesh(mesh);
					});

					return true;

				}else
					return false;
			},

			craftMesh : function(){
				var mat = MAT.color.clone();
				mat.uniforms.color.value = COLOR.RGB[this.color];

				return new THREE.Mesh(GEO.dot, mat);
			}
		};

		var TYPE = {
			GROUND: 0,
			WALL: 1,
			SNAKE: 2,

			SWAPERBLACK: 3,
			SWAPERGREEN: 4,
			SWAPERRED: 5,
			SWAPERYELLOW: 6,

			LIST: [
				new Block(0),
				new Block(1),
				new SnakePart(),

				new ColorSwaper( COLOR.BLACK),
				new ColorSwaper( COLOR.GREEN),
				new ColorSwaper( COLOR.RED),
				new ColorSwaper( COLOR.YELLOW),
				new ColorSwaper( COLOR.BLUE),
				new ColorSwaper( COLOR.CYAN),
				new ColorSwaper( COLOR.VIOLET),
				new ColorSwaper( COLOR.WHITE),

				new Dot( COLOR.BLACK),
				new Dot( COLOR.GREEN),
				new Dot( COLOR.RED),
				new Dot( COLOR.YELLOW),
				new Dot( COLOR.BLUE),
				new Dot( COLOR.CYAN),
				new Dot( COLOR.VIOLET),
				new Dot( COLOR.WHITE)
			]
		};
		TYPE.LIST['undefined'] = TYPE.LIST[0];


//- RENDERMANAGER
		function RenderManager(){
			this.cam = new THREE.PerspectiveCamera(FOV, window.innerWidth/window.innerHeight, 1, 100);
			this.renderer = new THREE.WebGLRenderer({antialias: false});
			this.renderer.setClearColor( 0x888888, 1);

			this.scene = new THREE.Scene();
			this.grid;

			CANVAS = this.renderer.domElement;
			this.onRun = false;
			this.lastTick = 0;

			var self = this;
			window.onresize = function(){self.updateSize();};
   			this.updateSize();
		}

		RenderManager.prototype = {
			startUpdate : function(){
				this.onRun = true;
				this.lastTick = Date.now();
				this.update(this);
			},

			stopUpdate : function(){
				this.onRun = false;
			},

			update : function(rm){//rm => RenderManager
				var delta = Date.now() -rm.lastTick;
				if(delta > 40){
					delta = 40;
					rm.lastTick = Date.now();
				}

				rm.lastTick += delta;

				if(rm.onRun)
					requestAnimationFrame(function(){rm.update(rm);});

				rm.renderer.render(rm.scene, rm.cam);
				snake.update(delta);
				animationManager.update(delta);
			},

			updateSize : function(e){
				this.cam.aspect = window.innerWidth /window.innerHeight;
				this.cam.updateProjectionMatrix();

				this.renderer.setSize( window.innerWidth, window.innerHeight);
				CANVAS.style.height = window.innerHeight+'px';
				CANVAS.style.width = window.innerWidth +'px';

				SCREENY = window.innerHeight/2 * ( Math.cos( FOV/180*Math.PI/2 ) / Math.sin(FOV/180*Math.PI/2) );
			},

			initGrid : function(height, width){
				this.grid = [];
				this.ground = [];

				for(var i=0, j; i<width; i++){
					this.grid.push([]);

					for(j=0; j<height; j++)
						this.grid[i].push(null);
				}

				for(var i=0, j, endI=(width>>3)+1, endJ=(height>>3)+1; i<endI; i++){
					this.ground.push([]);

					for(j=0; j<endJ; j++){
						var mat = MAT.grayGradient.clone();
						mat.attributes = {grad : {type: 'f', value: []}};

						this.ground[i].push(new THREE.Mesh(new THREE.Geometry(), mat));
						this.scene.add( this.ground[i][j] );
					}
				}
			},

			clearGrid : function(){
				for(var i=0, j=0; i<this.grid.length; i++)
					for(j=0; j<this.grid[0].length; j++)
						if(this.grid[i][j] !== null){
							this.scene.remove(this.grid[i][j]);
							this.grid[i][j] = null;
						}
			},

			craftMesh : function(type, x, y){
				if(type === undefined)
					return;

				var mesh = type.mesh.clone();
				mesh.position.x = x;
				mesh.position.z = y;

				this.grid[x][y] = mesh;
				this.scene.add(mesh);
				return mesh;
			},

			clearPos : function(x, y){
				this.scene.remove(this.grid[x][y]);
				this.grid[x][y] = null;
			},

			clearMesh : function(mesh){
				this.scene.remove(mesh);
			},

			addMesh : function(mesh){
				this.scene.add(mesh);
			},

			addGround : function(type, x, y){
				if(type.ground !== true)
					return;
				
				var ground = type.mesh.clone();
				ground.position.x = x;
				ground.position.z = y;

				x>>=3;
				y>>=3;

				THREE.GeometryUtils.merge(this.ground[x][y].geometry, ground);

				var grad = this.ground[x][y].material.attributes.grad;
				grad.value = grad.value.concat(ground.material.attributes.grad.value);
			},

			clearGround : function(){
				for(var i=0, j; i<this.ground.length; i++)
					for(j=0; j<this.ground[0].length; j++)
						if(this.ground[i][j] !== null)
							this.scene.remove(this.ground[i][j]);
			},

			renderFrame : function(){
				this.renderer.render(this.scene, this.cam);
			}
		};


//- BUILDER

		function Builder(){
			this.buildArea = [];
			this.height = 10;
			this.width = 10;

			this.craftDefault();
		}

		Builder.prototype = {
			craftDefault : function(){
				this.buildArea = [];

				for(var i=0,j; i<this.width; i++){
					this.buildArea.push([]);

					for(j=0; j<this.height; j++)
						this.buildArea[i].push({data: 0, meshes:[
								this.addMesh(TYPE.ground)
							]});
				}
			},

			addMesh : function(id){
				var mesh = TYPE.LIST[id].clone();
				renderManager.addMesh( mesh );
				return mesh;
			},

			updatePos : function(typeId, x, y){
				this.clearPos(this.buildArea[x][y]);

				if(typeId === TYPE.wall || typeId === TYPE.ground)
					this.buildArea[x][y].meshes.push( this.addMesh(typeId) );

				else
					this.buildArea[x][y].meshes.push( 
						this.addMesh(TYPE.ground),
						this.addMesh(typeId)
					);

				this.buildArea[x][y].data = typeId;
			},

			setSize : function(height, width){
				if(this.height < height)
					for(var i=0, j; i<this.width; i++)
						for(j=this.height; j<height; j++)
							this.buildArea[i].push({data: 0, meshes:[
									this.addMesh(TYPE.ground)
								]});

				else if(this.height > height)
					for(var i=0, j; i<this.width; i++){
						for(j=height; j<this.height; j++)
							this.clearPos(this.buildArea[i][j]);

						this.buildArea[i].splice(height);
					}
				
				this.height = height;

				if(this.width < width)
					for(var i=this.width, j; i<width; i++){
						this.buildArea.push([]);

						for(j=0; j<this.height; j++)
							this.buildArea[i].push({data: 0, meshes:[
									this.addMesh(TYPE.ground)
								]});
					}

				else if(this.width > width)
					this.buildArea.splice(width);

				this.width = width;
			},

			clearPos : function(pos, start, end){
				for(var i=start||0, end=end||pos.meshes.length; i<end; i++)
					renderManager.clearMesh(pos.meshes[i]);
			}
		};

		function getGridPos(x, y){
			var offY = renderManager.cam.position.y * Math.tan(  Math.atan( (y - window.innerHeight/2) /SCREENY)  );
			var offX = renderManager.cam.position.y * Math.tan(  Math.atan( (x - window.innerWidth/2) /SCREENY)  );

			renderManager.cam.position.x += Math.round(offX);
			renderManager.cam.position.z += Math.round(offY);

			renderManager.renderFrame();

		};


//- MAIN
		var snake = new Snake();
		var map = new Map();
		var keyBinder = new KeyBinder();
		var renderManager = new RenderManager();
		var animationManager = new AnimationManager();

		window.addEventListener('click', function(e){console.log(e); getGridPos(e.x, e.y);},false);

		window.addEventListener('load', function(){
			document.body.appendChild(CANVAS);

			map.updateData({
				height: 20,
				width: 20,
				spawn: {x:0, y:0},
				dotCount: 5,
				grid: [
					0,3,4,5,6, 11,12,13,14,15,
					12,0,0,0,0, 0,0,0,0,0,
					12,0,1,1,1, 0,0,0,0,0,
					12,0,0,1,1, 0,0,0,0,0,
					12,0,1,0,1, 0,0,0,1,0,

					12,1,0,0,0, 1,0,1,0,0,
					12,0,0,0,0, 1,1,0,0,0,
					12,0,0,0,0, 1,1,1,0,0,
					12,0,0,0,0, 0,0,0,0,0,
					12,0,0,0,0, 0,0,0,0,0
				]});

			renderManager.cam.position.y = 5;
			renderManager.cam.position.x = 1;
			renderManager.cam.position.z = 1;
			renderManager.cam.rotation.order = 'YXZ';
			renderManager.cam.rotation.x = -Math.PI/2;/*-Math.PI/32*14;
			renderManager.cam.rotation.y = -Math.PI/32;*/

			renderManager.startUpdate();
		}, false);
	</script>
</head>
<body>
	<div id=score></div>
</body>
</html>